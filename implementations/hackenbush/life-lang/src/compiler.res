// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell
// hackenbush-ssg - Pattern Compiler (ReScript)
// Compiles pattern descriptions to RLE format

open Parser

// Pattern component types
type componentType =
  | GliderGun
  | Glider
  | Block
  | Blinker
  | Eater
  | Wire(int)  // length
  | Custom(string)

// Component placement
type placement = {
  component: componentType,
  x: int,
  y: int,
  rotation: int,  // 0, 90, 180, 270
}

// Compilation context
type compileContext = {
  width: int,
  height: int,
  placements: array<placement>,
}

// Create empty context
let createContext = (width: int, height: int): compileContext => {
  {
    width,
    height,
    placements: [],
  }
}

// Add component to context
let addComponent = (ctx: compileContext, placement: placement): compileContext => {
  {
    ...ctx,
    placements: Array.concat(ctx.placements, [placement]),
  }
}

// Get component pattern as cell grid
let getComponentPattern = (component: componentType): array<array<bool>> => {
  switch component {
  | Glider => [
      [false, true, false],
      [false, false, true],
      [true, true, true],
    ]
  | Block => [
      [true, true],
      [true, true],
    ]
  | Blinker => [
      [true],
      [true],
      [true],
    ]
  | Eater => [
      [false, false, true, true],
      [false, true, false, true],
      [false, true, false, false],
      [true, true, false, false],
    ]
  | GliderGun => {
      // Simplified Gosper glider gun representation
      let grid = Array.make(~length=9, Array.make(~length=36, false))
      // Note: Full pattern would be placed here
      grid
    }
  | Wire(length) => {
      // Empty space for wire (gliders travel through)
      Array.make(~length=1, Array.make(~length=length, false))
    }
  | Custom(_) => {
      // Would load from patterns/ directory
      [[false]]
    }
  }
}

// Rotate pattern 90 degrees clockwise
let rotatePattern = (pattern: array<array<bool>>): array<array<bool>> => {
  let height = Array.length(pattern)
  if height == 0 {
    pattern
  } else {
    let width = Array.length(Array.getUnsafe(pattern, 0))
    let rotated = Array.make(~length=width, Array.make(~length=height, false))

    for y in 0 to height - 1 {
      for x in 0 to width - 1 {
        let newX = height - 1 - y
        let newY = x
        let cell = Array.getUnsafe(Array.getUnsafe(pattern, y), x)
        Array.setUnsafe(Array.getUnsafe(rotated, newY), newX, cell)
      }
    }

    rotated
  }
}

// Apply rotation (0, 90, 180, 270 degrees)
let applyRotation = (pattern: array<array<bool>>, degrees: int): array<array<bool>> => {
  let rotations = (degrees / 90) mod 4
  let rec loop = (p, remaining) => {
    if remaining <= 0 {
      p
    } else {
      loop(rotatePattern(p), remaining - 1)
    }
  }
  loop(pattern, rotations)
}

// Compile context to cell grid
let compile = (ctx: compileContext): array<array<bool>> => {
  // Initialize empty grid
  let grid = Array.make(~length=ctx.height, Array.make(~length=ctx.width, false))

  // Place each component
  Array.forEach(ctx.placements, placement => {
    let pattern = getComponentPattern(placement.component)
    let rotated = applyRotation(pattern, placement.rotation)

    let patternHeight = Array.length(rotated)
    let patternWidth = if patternHeight > 0 {
      Array.length(Array.getUnsafe(rotated, 0))
    } else {
      0
    }

    for py in 0 to patternHeight - 1 {
      for px in 0 to patternWidth - 1 {
        let gx = placement.x + px
        let gy = placement.y + py

        if gx >= 0 && gx < ctx.width && gy >= 0 && gy < ctx.height {
          let cell = Array.getUnsafe(Array.getUnsafe(rotated, py), px)
          if cell {
            Array.setUnsafe(Array.getUnsafe(grid, gy), gx, true)
          }
        }
      }
    }
  })

  grid
}

// Convert grid to RLE format
let toRLE = (grid: array<array<bool>>, name: string): string => {
  let height = Array.length(grid)
  let width = if height > 0 { Array.length(Array.getUnsafe(grid, 0)) } else { 0 }

  let header = `#N ${name}
#C Generated by hackenbush-ssg compiler
#O hackenbush-ssg
x = ${Int.toString(width)}, y = ${Int.toString(height)}, rule = B3/S23
`

  let encodeRow = (row: array<bool>): string => {
    let result = ref("")
    let runLength = ref(0)
    let runChar = ref('b')

    Array.forEach(row, cell => {
      let char = if cell { 'o' } else { 'b' }
      if char == runChar.contents {
        runLength := runLength.contents + 1
      } else {
        if runLength.contents > 0 {
          if runLength.contents > 1 {
            result := result.contents ++ Int.toString(runLength.contents)
          }
          result := result.contents ++ String.make(1, runChar.contents)
        }
        runChar := char
        runLength := 1
      }
    })

    // Flush remaining run
    if runLength.contents > 0 && runChar.contents == 'o' {
      if runLength.contents > 1 {
        result := result.contents ++ Int.toString(runLength.contents)
      }
      result := result.contents ++ "o"
    }

    result.contents
  }

  let rows = Array.map(grid, encodeRow)
  let body = Array.join(rows, ~sep="$") ++ "!"

  header ++ body
}
