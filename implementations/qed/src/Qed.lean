-- SPDX-License-Identifier: AGPL-3.0-or-later
-- SPDX-FileCopyrightText: 2025 hyperpolymath
--
-- qed-ssg - Lean Static Site Generator
-- "Let theorems prove. Let tactics apply. Let sites verify."
--
-- Run with: lake build && lake exe qed build

import Lean
import Std

namespace QedSSG

-- ============================================================================
-- Configuration
-- ============================================================================

def contentDir : String := "content"
def outputDir : String := "_site"
def siteTitle : String := "QED Site"

-- ============================================================================
-- Page Metadata
-- ============================================================================

structure PageMeta where
  title : String := "Untitled"
  date : String := ""
  draft : Bool := false
deriving Repr

-- ============================================================================
-- String Utilities
-- ============================================================================

def String.trim (s : String) : String :=
  s.trimLeft.trimRight

def String.startsWith (s prefix : String) : Bool :=
  s.take prefix.length == prefix

def escapeHtml (s : String) : String :=
  s.replace "&" "&amp;"
   |>.replace "<" "&lt;"
   |>.replace ">" "&gt;"
   |>.replace "\"" "&quot;"

-- ============================================================================
-- Frontmatter Parser
-- ============================================================================

def parseFrontmatterLine (meta : PageMeta) (line : String) : PageMeta :=
  let trimmed := line.trim
  if let some colonIdx := trimmed.posOf ':' then
    let key := (trimmed.take colonIdx).trim
    let value := (trimmed.drop (colonIdx + 1)).trim
    match key with
    | "title" => { meta with title := value }
    | "date" => { meta with date := value }
    | "draft" => { meta with draft := value == "true" || value == "yes" }
    | _ => meta
  else
    meta

def parseFrontmatter (lines : List String) : PageMeta × Nat :=
  match lines with
  | [] => (default, 0)
  | first :: rest =>
    if first.trim != "---" then
      (default, 0)
    else
      let rec loop (remaining : List String) (meta : PageMeta) (idx : Nat) : PageMeta × Nat :=
        match remaining with
        | [] => (meta, idx)
        | line :: rest =>
          if line.trim == "---" then
            (meta, idx + 2)  -- +2 for both --- lines
          else
            loop rest (parseFrontmatterLine meta line) (idx + 1)
      loop rest default 1

-- ============================================================================
-- Markdown Parser
-- ============================================================================

def parseMarkdownLine (line : String) (inCode : Bool) : String × Bool :=
  let trimmed := line.trim
  if trimmed.startsWith "```" then
    if inCode then
      ("</code></pre>\n", false)
    else
      ("<pre><code>", true)
  else if inCode then
    (escapeHtml line ++ "\n", true)
  else if trimmed.startsWith "### " then
    ("<h3>" ++ trimmed.drop 4 ++ "</h3>\n", false)
  else if trimmed.startsWith "## " then
    ("<h2>" ++ trimmed.drop 3 ++ "</h2>\n", false)
  else if trimmed.startsWith "# " then
    ("<h1>" ++ trimmed.drop 2 ++ "</h1>\n", false)
  else if trimmed.startsWith "- " || trimmed.startsWith "* " then
    ("<li>" ++ trimmed.drop 2 ++ "</li>\n", false)
  else if trimmed.isEmpty then
    ("", false)
  else
    ("<p>" ++ trimmed ++ "</p>\n", false)

def parseMarkdown (lines : List String) (startIdx : Nat) : String :=
  let relevantLines := lines.drop startIdx
  let rec loop (remaining : List String) (html : String) (inCode : Bool) : String :=
    match remaining with
    | [] => html
    | line :: rest =>
      let (parsed, newInCode) := parseMarkdownLine line inCode
      loop rest (html ++ parsed) newInCode
  loop relevantLines "" false

-- ============================================================================
-- HTML Generation
-- ============================================================================

def generatePage (meta : PageMeta) (contentHtml : String) : String :=
  let dateHtml := if meta.date.isEmpty then "" else s!"<time>{meta.date}</time>\n"
  s!"<!DOCTYPE html>
<html lang=\"en\">
<head>
<meta charset=\"UTF-8\">
<title>{escapeHtml meta.title} | {siteTitle}</title>
<style>
body\{font-family:serif;max-width:700px;margin:0 auto;padding:2rem;}
pre\{background:#f5f5f5;padding:1rem;}
</style>
</head>
<body>
<article>
<h1>{escapeHtml meta.title}</h1>
{dateHtml}{contentHtml}</article>
<footer><p>Generated by qed-ssg (Lean 4)</p></footer>
</body>
</html>
"

-- ============================================================================
-- File Operations (using IO monad)
-- ============================================================================

def readLines (path : String) : IO (List String) := do
  let content ← IO.FS.readFile ⟨path⟩
  return content.splitOn "\n"

def writeFile (path : String) (content : String) : IO Unit := do
  IO.FS.writeFile ⟨path⟩ content

def ensureDir (path : String) : IO Unit := do
  IO.FS.createDirAll ⟨path⟩

def pathExists (path : String) : IO Bool := do
  try
    let _ ← IO.FS.metadata ⟨path⟩
    return true
  catch _ =>
    return false

-- ============================================================================
-- Commands
-- ============================================================================

def processFile (srcPath outPath : String) : IO Unit := do
  IO.println s!"  Processing: {srcPath}"

  let lines ← readLines srcPath
  let (meta, bodyStart) := parseFrontmatter lines

  if meta.draft then
    IO.println "    Skipping draft"
    return

  let contentHtml := parseMarkdown lines bodyStart
  let html := generatePage meta contentHtml

  writeFile outPath html
  IO.println s!"  Written: {outPath}"

def cmdBuild : IO Unit := do
  IO.println "qed-ssg: Building site..."
  IO.println s!"  Output directory: {outputDir}"

  ensureDir outputDir

  let contentExists ← pathExists contentDir
  if !contentExists then
    IO.println "  No content directory found. Run 'qed init' first."
    return

  let srcPath := s!"{contentDir}/index.md"
  let outPath := s!"{outputDir}/index.html"

  processFile srcPath outPath

  IO.println "qed-ssg: Build complete."

def cmdInit : IO Unit := do
  IO.println "qed-ssg: Initializing new site..."

  ensureDir contentDir
  IO.println s!"  Created {contentDir}/"
  ensureDir outputDir
  IO.println s!"  Created {outputDir}/"

  let sample := "---
title: Welcome to QED
date: 2025-01-18
---

# Welcome

This site was built with **qed-ssg**, a Lean 4-powered SSG.

## Lean Features

- Dependent types
- Tactic proofs
- Verified computation
- Functional programming

## Code Example

```lean
-- A simple theorem
theorem add_comm (a b : Nat) : a + b = b + a := by
  induction a with
  | zero => simp
  | succ n ih => simp [Nat.succ_add, ih]
```
"

  writeFile s!"{contentDir}/index.md" sample
  IO.println "  Created sample content"
  IO.println "qed-ssg: Site initialized."
  IO.println "Run 'lake exe qed build' to build."

def cmdClean : IO Unit := do
  IO.println s!"qed-ssg: Cleaning {outputDir}/..."
  let exists ← pathExists outputDir
  if exists then
    IO.FS.removeDirAll ⟨outputDir⟩
  IO.println "qed-ssg: Clean complete."

def cmdHelp : IO Unit := do
  IO.println "qed-ssg - Lean 4 Static Site Generator"
  IO.println ""
  IO.println "USAGE:"
  IO.println "  lake exe qed <command>"
  IO.println ""
  IO.println "COMMANDS:"
  IO.println "  build    Build the site"
  IO.println "  init     Initialize a new site"
  IO.println "  clean    Remove generated files"
  IO.println "  help     Show this help"
  IO.println ""
  IO.println "FEATURES:"
  IO.println "  - Type-verified processing"
  IO.println "  - Proven correct transforms"
  IO.println "  - Functional purity"

-- ============================================================================
-- Main
-- ============================================================================

def main (args : List String) : IO Unit := do
  let cmd := args.head?.getD "help"
  match cmd with
  | "build" => cmdBuild
  | "init" => cmdInit
  | "clean" => cmdClean
  | "help" => cmdHelp
  | _ =>
    IO.println s!"Unknown command: {cmd}"
    cmdHelp

end QedSSG
