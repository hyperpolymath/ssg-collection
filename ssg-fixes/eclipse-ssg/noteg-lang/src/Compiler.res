// SPDX-License-Identifier: AGPL-3.0-or-later
// SPDX-FileCopyrightText: 2025 Jonathan D.A. Jewell
// Compiler.res â€” NoteG language compiler (to JavaScript)

open Parser

// ============================================================
// COMPILER STATE
// ============================================================

type compilerState = {
  mutable indent: int,
}

let create = (): compilerState => {
  indent: 0,
}

let getIndent = (state: compilerState): string => {
  Js.String2.repeat("  ", state.indent)
}

// ============================================================
// LITERAL COMPILER
// ============================================================

let compileLiteral = (value: literalValue): string => {
  switch value {
  | StringLit(s) => Js.Json.stringify(Js.Json.string(s))
  | NumberLit(n) => Float.toString(n)
  | BoolLit(b) => b ? "true" : "false"
  | NullLit => "null"
  }
}

// ============================================================
// NODE COMPILER
// ============================================================

let rec compileNode = (state: compilerState, node: astNode): string => {
  switch node {
  | Program(body) =>
    let lines = ["// Generated by NoteG Compiler", "// SPDX-License-Identifier: AGPL-3.0-or-later", ""]
    let compiledBody = body->Array.map(n => compileNode(state, n))
    Array.concat(lines, compiledBody)->Array.joinWith("\n")

  | LetDecl({name, value}) =>
    let compiledValue = compileNode(state, value)
    getIndent(state) ++ "const " ++ name ++ " = " ++ compiledValue ++ ";"

  | FunctionDecl({name, params, body}) =>
    let paramsStr = params->Array.joinWith(", ")
    let compiledBody = compileNode(state, body)
    getIndent(state) ++ "function " ++ name ++ "(" ++ paramsStr ++ ") " ++ compiledBody

  | IfStmt({condition, thenBranch, elseBranch}) =>
    let compiledCondition = compileNode(state, condition)
    let compiledThen = compileNode(state, thenBranch)
    let result = getIndent(state) ++ "if (" ++ compiledCondition ++ ") " ++ compiledThen
    switch elseBranch {
    | Some(elseNode) =>
      let compiledElse = compileNode(state, elseNode)
      result ++ " else " ++ compiledElse
    | None => result
    }

  | ForStmt({variable, iterable, body}) =>
    let compiledIterable = compileNode(state, iterable)
    let compiledBody = compileNode(state, body)
    getIndent(state) ++ "for (const " ++ variable ++ " of " ++ compiledIterable ++ ") " ++ compiledBody

  | WhileStmt({condition, body}) =>
    let compiledCondition = compileNode(state, condition)
    let compiledBody = compileNode(state, body)
    getIndent(state) ++ "while (" ++ compiledCondition ++ ") " ++ compiledBody

  | ReturnStmt({value}) =>
    switch value {
    | Some(v) =>
      let compiledValue = compileNode(state, v)
      getIndent(state) ++ "return " ++ compiledValue ++ ";"
    | None => getIndent(state) ++ "return;"
    }

  | Block({statements}) =>
    state.indent = state.indent + 1
    let compiledStatements = statements->Array.map(s => compileNode(state, s))->Array.joinWith("\n")
    state.indent = state.indent - 1
    "{\n" ++ compiledStatements ++ "\n" ++ getIndent(state) ++ "}"

  | BinaryExpr({operator, left, right}) =>
    let compiledLeft = compileNode(state, left)
    let compiledRight = compileNode(state, right)
    let op = switch operator {
    | "and" => "&&"
    | "or" => "||"
    | other => other
    }
    "(" ++ compiledLeft ++ " " ++ op ++ " " ++ compiledRight ++ ")"

  | UnaryExpr({operator, operand}) =>
    let compiledOperand = compileNode(state, operand)
    let op = switch operator {
    | "not" => "!"
    | other => other
    }
    op ++ compiledOperand

  | CallExpr({callee, args}) =>
    let compiledCallee = compileNode(state, callee)
    let compiledArgs = args->Array.map(a => compileNode(state, a))->Array.joinWith(", ")
    compiledCallee ++ "(" ++ compiledArgs ++ ")"

  | IdentifierExpr({name}) => name

  | LiteralExpr({value}) => compileLiteral(value)

  | ArrayExpr({elements}) =>
    let compiledElements = elements->Array.map(e => compileNode(state, e))->Array.joinWith(", ")
    "[" ++ compiledElements ++ "]"

  | ObjectExpr({properties}) =>
    let compiledProps =
      properties
      ->Array.map(((key, value)) => key ++ ": " ++ compileNode(state, value))
      ->Array.joinWith(", ")
    "{" ++ compiledProps ++ "}"

  | TemplateExpr({variable}) => "${" ++ variable ++ "}"
  }
}

// ============================================================
// MAIN COMPILER
// ============================================================

let compile = (program: astNode): string => {
  let state = create()
  compileNode(state, program)
}

let compileSource = (source: string): string => {
  let ast = parseSource(source)
  compile(ast)
}
