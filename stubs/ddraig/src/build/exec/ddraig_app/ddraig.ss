#!/usr/bin/scheme --program

;; @generated by Idris 0.8.0, Chez backend
(import (chezscheme))
(case (machine-type)
  [(i3fb ti3fb a6fb ta6fb) #f]
  [(i3le ti3le a6le ta6le tarm64le)
     (with-exception-handler (lambda(x) (load-shared-object "libc.so"))
        (lambda () (load-shared-object "libc.so.6")))]
  [(i3osx ti3osx a6osx ta6osx tarm64osx tppc32osx tppc64osx) (load-shared-object "libc.dylib")]
  [(i3nt ti3nt a6nt ta6nt) (load-shared-object "msvcrt.dll")]
  [else (load-shared-object "libc.so")])

(load-shared-object "libidris2_support.so")

(let ()
#!chezscheme

(define (blodwen-os)
  (case (machine-type)
    [(i3le ti3le a6le ta6le tarm64le) "unix"]  ; GNU/Linux
    [(i3ob ti3ob a6ob ta6ob tarm64ob) "unix"]  ; OpenBSD
    [(i3fb ti3fb a6fb ta6fb tarm64fb) "unix"]  ; FreeBSD
    [(i3nb ti3nb a6nb ta6nb tarm64nb) "unix"]  ; NetBSD
    [(i3osx ti3osx a6osx ta6osx tarm64osx tppc32osx tppc64osx) "darwin"]
    [(i3nt ti3nt a6nt ta6nt tarm64nt) "windows"]
    [else "unknown"]))

(define blodwen-lazy
  (lambda (f)
    (let ([evaluated #f] [res void])
      (lambda ()
        (if (not evaluated)
            (begin (set! evaluated #t)
                   (set! res (f))
                   (set! f void))
            (void))
        res))))

(define (blodwen-delay-lazy f)
  (weak-cons #!bwp f))

(define (blodwen-force-lazy e)
  (let ((exval (car e)))
    (if (bwp-object? exval)
      (let ((val ((cdr e))))
        (begin (set-car! e val) val))
      exval)))

(define (blodwen-toSignedInt x bits)
  (if (logbit? bits x)
      (logor x (ash -1 bits))
      (logand x (sub1 (ash 1 bits)))))

(define (blodwen-toUnsignedInt x bits)
  (logand x (sub1 (ash 1 bits))))

(define (blodwen-euclidDiv a b)
  (let ((q (quotient a b))
        (r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (- q 1) (+ q 1))
      q)))

(define (blodwen-euclidMod a b)
  (let ((r (remainder a b)))
    (if (< r 0)
      (if (> b 0) (+ r b) (- r b))
      r)))

; flonum constants

(define (blodwen-calcFlonumUnitRoundoff)
  (let loop [(uro 1.0)]
    (if (fl= 1.0 (fl+ 1.0 uro))
      uro
      (loop (fl/ uro 2.0)))))

(define (blodwen-calcFlonumEpsilon)
  (fl* (blodwen-calcFlonumUnitRoundoff) 2.0))

(define (blodwen-flonumNaN)
  +nan.0)

(define (blodwen-flonumInf)
  +inf.0)

; Bits

(define bu+ (lambda (x y bits) (blodwen-toUnsignedInt (+ x y) bits)))
(define bu- (lambda (x y bits) (blodwen-toUnsignedInt (- x y) bits)))
(define bu* (lambda (x y bits) (blodwen-toUnsignedInt (* x y) bits)))
(define bu/ (lambda (x y bits) (blodwen-toUnsignedInt (quotient x y) bits)))

(define bs+ (lambda (x y bits) (blodwen-toSignedInt (+ x y) bits)))
(define bs- (lambda (x y bits) (blodwen-toSignedInt (- x y) bits)))
(define bs* (lambda (x y bits) (blodwen-toSignedInt (* x y) bits)))
(define bs/ (lambda (x y bits) (blodwen-toSignedInt (blodwen-euclidDiv x y) bits)))

(define (integer->bits8 x) (logand x (sub1 (ash 1 8))))
(define (integer->bits16 x) (logand x (sub1 (ash 1 16))))
(define (integer->bits32 x) (logand x (sub1 (ash 1 32))))
(define (integer->bits64 x) (logand x (sub1 (ash 1 64))))

(define (bits16->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits64->bits8 x) (logand x (sub1 (ash 1 8))))
(define (bits32->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits16 x) (logand x (sub1 (ash 1 16))))
(define (bits64->bits32 x) (logand x (sub1 (ash 1 32))))

(define (blodwen-bits-shl-signed x y bits) (blodwen-toSignedInt (ash x y) bits))

(define (blodwen-bits-shl x y bits) (logand (ash x y) (sub1 (ash 1 bits))))

(define blodwen-shl (lambda (x y) (ash x y)))
(define blodwen-shr (lambda (x y) (ash x (- y))))
(define blodwen-and (lambda (x y) (logand x y)))
(define blodwen-or (lambda (x y) (logor x y)))
(define blodwen-xor (lambda (x y) (logxor x y)))

(define cast-num
  (lambda (x)
    (if (number? x) x 0)))
(define destroy-prefix
  (lambda (x)
    (cond
      ((equal? x "") "")
      ((equal? (string-ref x 0) #\#) "")
      (else x))))

(define exact-floor
  (lambda (x)
    (inexact->exact (floor x))))

(define exact-truncate
  (lambda (x)
    (inexact->exact (truncate x))))

(define exact-truncate-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (exact-truncate x) y)))

(define exact-truncate-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (exact-truncate x) y)))

(define cast-char-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (char->integer x) y)))

(define cast-char-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (char->integer x) y)))

(define cast-string-int
  (lambda (x)
    (exact-truncate (cast-num (string->number (destroy-prefix x))))))

(define cast-string-boundedInt
  (lambda (x y)
    (blodwen-toSignedInt (cast-string-int x) y)))

(define cast-string-boundedUInt
  (lambda (x y)
    (blodwen-toUnsignedInt (cast-string-int x) y)))

(define cast-int-char
  (lambda (x)
    (if (or
          (and (>= x 0) (<= x #xd7ff))
          (and (>= x #xe000) (<= x #x10ffff)))
        (integer->char x)
        (integer->char 0))))

(define cast-string-double
  (lambda (x)
    (exact->inexact (cast-num (string->number (destroy-prefix x))))))


(define (string-concat xs) (apply string-append xs))
(define (string-unpack s) (string->list s))
(define (string-pack xs) (list->string xs))

(define string-cons (lambda (x y) (string-append (string x) y)))
(define string-reverse (lambda (x)
  (list->string (reverse (string->list x)))))
(define (string-substr off len s)
    (let* ((l (string-length s))
          (b (max 0 off))
          (x (max 0 len))
          (end (min l (+ b x))))
          (if (> b l)
              ""
              (substring s b end))))

(define (blodwen-string-iterator-new s)
  0)

(define (blodwen-string-iterator-to-string _ s ofs f)
  (f (substring s ofs (string-length s))))

(define (blodwen-string-iterator-next s ofs)
  (if (>= ofs (string-length s))
      '() ; EOF
      (cons (string-ref s ofs) (+ ofs 1))))

(define either-left
  (lambda (x)
    (vector 0 x)))

(define either-right
  (lambda (x)
    (vector 1 x)))

(define blodwen-error-quit
  (lambda (msg)
    (display msg)
    (newline)
    (exit 1)))

(define (blodwen-get-line p)
    (if (port? p)
        (let ((str (get-line p)))
            (if (eof-object? str)
                ""
                str))
        void))

(define (blodwen-get-char p)
    (if (port? p)
        (let ((chr (get-char p)))
            (if (eof-object? chr)
                #\nul
                chr))
        void))

;; Buffers

(define (blodwen-new-buffer size)
  (make-bytevector size 0))

(define (blodwen-buffer-size buf)
  (bytevector-length buf))

(define (blodwen-buffer-setbyte buf loc val)
  (bytevector-u8-set! buf loc val))

(define (blodwen-buffer-getbyte buf loc)
  (bytevector-u8-ref buf loc))

(define (blodwen-buffer-setbits16 buf loc val)
  (bytevector-u16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits16 buf loc)
  (bytevector-u16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits32 buf loc val)
  (bytevector-u32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits32 buf loc)
  (bytevector-u32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setbits64 buf loc val)
  (bytevector-u64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getbits64 buf loc)
  (bytevector-u64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint8 buf loc val)
  (bytevector-s8-set! buf loc val))

(define (blodwen-buffer-getint8 buf loc)
  (bytevector-s8-ref buf loc))

(define (blodwen-buffer-setint16 buf loc val)
  (bytevector-s16-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint16 buf loc)
  (bytevector-s16-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint32 buf loc val)
  (bytevector-s32-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint32 buf loc)
  (bytevector-s32-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setint64 buf loc val)
  (bytevector-s64-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getint64 buf loc)
  (bytevector-s64-ref buf loc (native-endianness)))

(define (blodwen-buffer-setdouble buf loc val)
  (bytevector-ieee-double-set! buf loc val (native-endianness)))

(define (blodwen-buffer-getdouble buf loc)
  (bytevector-ieee-double-ref buf loc (native-endianness)))

(define (blodwen-stringbytelen str)
  (bytevector-length (string->utf8 str)))

(define (blodwen-buffer-setstring buf loc val)
  (let* [(strvec (string->utf8 val))
         (len (bytevector-length strvec))]
    (bytevector-copy! strvec 0 buf loc len)))

(define (blodwen-buffer-getstring buf loc len)
  (let [(newvec (make-bytevector len))]
    (bytevector-copy! buf loc newvec 0 len)
    (utf8->string newvec)))

(define (blodwen-buffer-copydata buf start len dest loc)
  (bytevector-copy! buf start dest loc len))

;; Threads

(define-record thread-handle (semaphore))

(define (blodwen-thread proc)
  (let [(sema (blodwen-make-semaphore 0))]
    (fork-thread (lambda () (proc (vector 0)) (blodwen-semaphore-post sema)))
    (make-thread-handle sema)
    ))

(define (blodwen-thread-wait handle)
  (blodwen-semaphore-wait (thread-handle-semaphore handle)))

;; Thread mailboxes

(define blodwen-thread-data
  (make-thread-parameter #f))

(define (blodwen-get-thread-data ty)
  (blodwen-thread-data))

(define (blodwen-set-thread-data ty a)
  (blodwen-thread-data a))

;; Semaphore

(define-record semaphore (box mutex condition))

(define (blodwen-make-semaphore init)
  (make-semaphore (box init) (make-mutex) (make-condition)))

(define (blodwen-semaphore-post sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (set-box! sema-box (+ (unbox sema-box) 1))
      (condition-signal (semaphore-condition sema))
    )))

(define (blodwen-semaphore-wait sema)
  (with-mutex (semaphore-mutex sema)
    (let [(sema-box (semaphore-box sema))]
      (when (= (unbox sema-box) 0)
        (condition-wait (semaphore-condition sema) (semaphore-mutex sema)))
      (set-box! sema-box (- (unbox sema-box) 1))
      )))

;; Barrier

(define-record barrier (count-box num-threads mutex cond))

(define (blodwen-make-barrier num-threads)
  (make-barrier (box 0) num-threads (make-mutex) (make-condition)))

(define (blodwen-barrier-wait barrier)
  (let [(count-box (barrier-count-box barrier))
        (num-threads (barrier-num-threads barrier))
        (mutex (barrier-mutex barrier))
        (condition (barrier-cond barrier))]
    (with-mutex mutex
    (let* [(count-old (unbox count-box))
           (count-new (+ count-old 1))]
      (set-box! count-box count-new)
      (if (= count-new num-threads)
          (condition-broadcast condition)
          (condition-wait condition mutex))
      ))))

;; Channel
; With thanks to Alain Zscheile (@zseri) for help with understanding condition
; variables, and figuring out where the problems were and how to solve them.

(define-record channel (read-mut read-cv read-box val-cv val-box))

(define (blodwen-make-channel ty)
  (make-channel
    (make-mutex)
    (make-condition)
    (box #t)
    (make-condition)
    (box '())
    ))

; block on the read status using read-cv until the value has been read
(define (channel-put-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [read-cv  (channel-read-cv  chan)]
        )
    (if (unbox read-box)
      (void)    ; val has been read, so everything is fine
      (begin    ; otherwise, block/spin with cv
        (condition-wait read-cv read-mut)
        (channel-put-while-helper chan)
        )
      )))

(define (blodwen-channel-put ty chan val)
  (with-mutex (channel-read-mut chan)
    (channel-put-while-helper chan)
    (let ([read-box (channel-read-box chan)]
          [val-box  (channel-val-box  chan)]
          )
      (set-box! val-box val)
      (set-box! read-box #f)
      ))
  (condition-signal (channel-val-cv chan))
  )

; block on the value until it has been set
(define (channel-get-while-helper chan)
  (let ([read-mut (channel-read-mut chan)]
        [read-box (channel-read-box chan)]
        [val-cv   (channel-val-cv   chan)]
        )
    (if (unbox read-box)
      (begin
        (condition-wait val-cv read-mut)
        (channel-get-while-helper chan)
        )
      (void)
      )))

(define (blodwen-channel-get ty chan)
  (mutex-acquire (channel-read-mut chan))
  (channel-get-while-helper chan)
  (let* ([val-box  (channel-val-box  chan)]
         [read-box (channel-read-box chan)]
         [read-cv  (channel-read-cv  chan)]
         [the-val  (unbox val-box)]
         )
    (set-box! val-box '())
    (set-box! read-box #t)
    (mutex-release (channel-read-mut chan))
    (condition-signal read-cv)
    the-val))

(define (blodwen-channel-get-non-blocking ty chan)
  (if (mutex-acquire (channel-read-mut chan) #f)
    (let* ([val-box  (channel-val-box  chan)]
           [read-box (channel-read-box chan)]
           [read-cv  (channel-read-cv  chan)]
           [the-val  (unbox val-box)]
          )
      (if (null? the-val)
          (begin
           (mutex-release (channel-read-mut chan))
           '())
          (begin
            (set-box! val-box '())
            (set-box! read-box #t)
            (mutex-release (channel-read-mut chan))
            (condition-signal read-cv)
            (box the-val))
      ))
  '()))

(define (blodwen-channel-get-with-timeout ty chan timeout)
  ;; timeout is in milliseconds, convert to nanoseconds
  (let* ([timeout-ns (* timeout 1000000)]
         [sleep-ns 10000] ; 10 us step
         [sleep-time (make-time 'time-duration (mod sleep-ns 1000000000)
                                                (div sleep-ns 1000000000))])
    (let loop ([elapsed 0])
      (if (mutex-acquire (channel-read-mut chan) #f)
          (let* ([val-box  (channel-val-box chan)]
                 [the-val  (unbox val-box)])
            (if (null? the-val)
                (if (>= elapsed timeout-ns)
                    (begin
                      (mutex-release (channel-read-mut chan))
                      '())
                    (begin
                      (mutex-release (channel-read-mut chan))
                      (sleep sleep-time)
                      (loop (+ elapsed sleep-ns))))
                (let* ([read-box (channel-read-box chan)]
                       [read-cv  (channel-read-cv chan)])
                  (set-box! val-box '())
                  (set-box! read-box #t)
                  (mutex-release (channel-read-mut chan))
                  (condition-signal read-cv)
                  (box the-val))))
          (begin
            (sleep sleep-time)
            (loop (+ elapsed sleep-ns)))))))

;; Mutex

(define (blodwen-make-mutex)
  (make-mutex))
(define (blodwen-mutex-acquire mutex)
  (mutex-acquire mutex))
(define (blodwen-mutex-release mutex)
  (mutex-release mutex))

;; Condition variable

(define (blodwen-make-condition)
  (make-condition))
(define (blodwen-condition-wait condition mutex)
  (condition-wait condition mutex))
(define (blodwen-condition-wait-timeout condition mutex timeout)
  (let* [(sec (div timeout 1000000))
         (micro (mod timeout 1000000))]
    (condition-wait condition mutex (make-time 'time-duration (* 1000 micro) sec))))
(define (blodwen-condition-signal condition)
  (condition-signal condition))
(define (blodwen-condition-broadcast condition)
  (condition-broadcast condition))

;; Future

(define-record future-internal (result ready mutex signal))
(define (blodwen-make-future ty work)
  (let ([future (make-future-internal #f #f (make-mutex) (make-condition))])
    (fork-thread (lambda ()
      (let ([result (work '())])
        (with-mutex (future-internal-mutex future)
          (set-future-internal-result! future result)
          (set-future-internal-ready! future #t)
          (condition-broadcast (future-internal-signal future))))))
    future))
(define (blodwen-await-future ty future)
  (let ([mutex (future-internal-mutex future)])
    (with-mutex mutex
      (if (not (future-internal-ready future))
          (condition-wait (future-internal-signal future) mutex))
      (future-internal-result future))))

(define (blodwen-sleep s) (sleep (make-time 'time-duration 0 s)))
(define (blodwen-usleep s)
  (let ((sec (div s 1000000))
        (micro (mod s 1000000)))
       (sleep (make-time 'time-duration (* 1000 micro) sec))))

(define (blodwen-clock-time-utc) (current-time 'time-utc))
(define (blodwen-clock-time-monotonic) (current-time 'time-monotonic))
(define (blodwen-clock-time-duration) (current-time 'time-duration))
(define (blodwen-clock-time-process) (current-time 'time-process))
(define (blodwen-clock-time-thread) (current-time 'time-thread))
(define (blodwen-clock-time-gccpu) (current-time 'time-collector-cpu))
(define (blodwen-clock-time-gcreal) (current-time 'time-collector-real))
(define (blodwen-is-time? clk) (if (time? clk) 1 0))
(define (blodwen-clock-second time) (time-second time))
(define (blodwen-clock-nanosecond time) (time-nanosecond time))

(define (blodwen-arg-count)
  (length (command-line)))

(define (blodwen-arg n)
  (if (< n (length (command-line))) (list-ref (command-line) n) ""))

(define (blodwen-hasenv var)
  (if (eq? (getenv var) #f) 0 1))

;; Randoms
(define random-seed-register 0)
(define (initialize-random-seed-once)
  (if (= (virtual-register random-seed-register) 0)
      (let ([seed (time-nanosecond (current-time))])
        (set-virtual-register! random-seed-register seed)
        (random-seed seed))))

(define (blodwen-random-seed seed)
  (set-virtual-register! random-seed-register seed)
  (random-seed seed))
(define blodwen-random
  (case-lambda
    ;; no argument, pick a real value from [0, 1.0)
    [() (begin
          (initialize-random-seed-once)
          (random 1.0))]
    ;; single argument k, pick an integral value from [0, k)
    [(k)
      (begin
        (initialize-random-seed-once)
        (if (> k 0)
              (random k)
              (assertion-violationf 'blodwen-random "invalid range argument ~a" k)))]))

;; For finalisers

(define blodwen-finaliser (make-guardian))
(define (blodwen-register-object obj proc)
  (let [(x (cons obj proc))]
       (blodwen-finaliser x)
       x))
(define blodwen-run-finalisers
  (lambda ()
    (let run ()
      (let ([x (blodwen-finaliser)])
        (when x
          (((cdr x) (car x)) 'erased)
          (run))))))

;; For creating and reading back scheme objects

; read a scheme string and evaluate it, returning 'Just result' on success
; TODO: catch exception!
(define (blodwen-eval-scheme str)
  (guard
     (x [#t '()]) ; Nothing on failure
     (box (eval (read (open-input-string str)))))
  ); box == Just

(define (blodwen-eval-okay obj)
  (if (null? obj)
      0
      1))

(define (blodwen-get-eval-result obj)
  (unbox obj))

(define (blodwen-debug-scheme obj)
  (display obj) (newline))

(define (blodwen-is-number obj)
  (if (number? obj) 1 0))

(define (blodwen-is-integer obj)
  (if (and (number? obj) (exact? obj)) 1 0))

(define (blodwen-is-float obj)
  (if (flonum? obj) 1 0))

(define (blodwen-is-char obj)
  (if (char? obj) 1 0))

(define (blodwen-is-string obj)
  (if (string? obj) 1 0))

(define (blodwen-is-procedure obj)
  (if (procedure? obj) 1 0))

(define (blodwen-is-symbol obj)
  (if (symbol? obj) 1 0))

(define (blodwen-is-vector obj)
  (if (vector? obj) 1 0))

(define (blodwen-is-nil obj)
  (if (null? obj) 1 0))

(define (blodwen-is-pair obj)
  (if (pair? obj) 1 0))

(define (blodwen-is-box obj)
  (if (box? obj) 1 0))

(define (blodwen-make-symbol str)
  (string->symbol str))

; The below rely on checking that the objects are the right type first.

(define (blodwen-vector-ref obj i)
  (vector-ref obj i))

(define (blodwen-vector-length obj)
  (vector-length obj))

(define (blodwen-vector-list obj)
  (vector->list obj))

(define (blodwen-unbox obj)
  (unbox obj))

(define (blodwen-apply obj arg)
  (obj arg))

(define (blodwen-force obj)
  (obj))

(define (blodwen-read-symbol sym)
  (symbol->string sym))

(define (blodwen-id x) x)
(define PreludeC-45Types-fastUnpack (lambda (farg-0) (string-unpack farg-0)))
(define PreludeC-45Types-fastPack (lambda (farg-0) (string-pack farg-0)))
(define PreludeC-45Types-fastConcat (lambda (farg-0) (string-concat farg-0)))
(define PreludeC-45IO-prim__putStr (lambda (farg-0 farg-1) ((foreign-procedure "idris2_putStr" (string) void) farg-0)))
(define System-prim__getArgCount (lambda (farg-0) (blodwen-arg-count )))
(define System-prim__getArg (lambda (farg-0 farg-1) (blodwen-arg farg-0)))
(define csegen-65 (vector (lambda (arg-5927) (lambda (arg-5930) (bs+ arg-5927 arg-5930 63))) (lambda (arg-5937) (lambda (arg-5940) (bs* arg-5937 arg-5940 63))) (lambda (arg-5947) (blodwen-toSignedInt arg-5947 63))))
(define u--prim__sub_Integer (lambda (arg-0 arg-1) (- arg-0 arg-1)))
(define PreludeC-45Types-getAt (lambda (arg-1 arg-2) (cond ((equal? arg-1 0) (if (null? arg-2) '() (let ((e-3 (car arg-2))) (box e-3))))(else (let ((e-1 (- arg-1 1))) (if (null? arg-2) '() (let ((e-7 (cdr arg-2))) (PreludeC-45Types-getAt e-1 e-7))))))))
(define PreludeC-45EqOrd-u--C-60C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char<=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62C-61_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char>=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Types-isDigit (lambda (arg-0) (let ((sc0 (PreludeC-45EqOrd-u--C-62C-61_Ord_Char arg-0 #\0))) (cond ((equal? sc0 1) (PreludeC-45EqOrd-u--C-60C-61_Ord_Char arg-0 #\9)) (else 0)))))
(define PreludeC-45Types-prim__integerToNat (lambda (arg-0) (let ((sc0 (or (and (<= 0 arg-0) 1) 0))) (cond ((equal? sc0 0) 0)(else arg-0)))))
(define PreludeC-45Show-firstCharIs (lambda (arg-0 arg-1) (cond ((equal? arg-1 "") 0)(else (arg-0 (string-ref arg-1 0))))))
(define PreludeC-45Show-protectEsc (lambda (arg-0 arg-1 arg-2) (string-append arg-1 (string-append (let ((sc0 (PreludeC-45Show-firstCharIs arg-0 arg-2))) (cond ((equal? sc0 1) "\\&") (else ""))) arg-2))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62_Ord_Char (lambda (arg-0 arg-1) (let ((sc0 (or (and (char>? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Show-showParens (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) arg-1) (else (string-append "(" (string-append arg-1 ")"))))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (lambda (arg-0 arg-1) (cond ((equal? arg-0 0) (cond ((equal? arg-1 0) 1)(else 0))) ((equal? arg-0 1) (cond ((equal? arg-1 1) 1)(else 0))) ((equal? arg-0 2) (cond ((equal? arg-1 2) 1)(else 0)))(else 0))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45Show-precCon (lambda (arg-0) (case (vector-ref arg-0 0) ((0) 0) ((1) 1) ((2) 2) ((3) 3) ((4) 4) ((5) 5) (else 6))))
(define PreludeC-45EqOrd-u--C-60_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Integer (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--compare_Ord_Integer (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Integer arg-0 arg-1))) (cond ((equal? sc1 1) 1) (else 2))))))))
(define PreludeC-45Show-u--compare_Ord_Prec (lambda (arg-0 arg-1) (case (vector-ref arg-0 0) ((4) (let ((e-0 (vector-ref arg-0 1))) (case (vector-ref arg-1 0) ((4) (let ((e-1 (vector-ref arg-1 1))) (PreludeC-45EqOrd-u--compare_Ord_Integer e-0 e-1)))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))(else (PreludeC-45EqOrd-u--compare_Ord_Integer (PreludeC-45Show-precCon arg-0) (PreludeC-45Show-precCon arg-1))))))
(define PreludeC-45Show-u--C-62C-61_Ord_Prec (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-47C-61_Eq_Ordering (PreludeC-45Show-u--compare_Ord_Prec arg-0 arg-1) 0)))
(define PreludeC-45Show-primNumShow (lambda (arg-1 arg-2 arg-3) (let ((u--str (arg-1 arg-3))) (PreludeC-45Show-showParens (let ((sc0 (PreludeC-45Show-u--C-62C-61_Ord_Prec arg-2 (vector 5 )))) (cond ((equal? sc0 1) (PreludeC-45Show-firstCharIs (lambda (arg-0) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 #\-)) u--str)) (else 0))) u--str))))
(define PreludeC-45Show-u--showPrec_Show_Int (lambda (ext-0 ext-1) (PreludeC-45Show-primNumShow (lambda (eta-0) (number->string eta-0)) ext-0 ext-1)))
(define PreludeC-45Show-u--show_Show_Int (lambda (arg-0) (PreludeC-45Show-u--showPrec_Show_Int (vector 0 ) arg-0)))
(define PreludeC-45Show-n--2434-11912-u--asciiTab (lambda (arg-0) (cons "NUL" (cons "SOH" (cons "STX" (cons "ETX" (cons "EOT" (cons "ENQ" (cons "ACK" (cons "BEL" (cons "BS" (cons "HT" (cons "LF" (cons "VT" (cons "FF" (cons "CR" (cons "SO" (cons "SI" (cons "DLE" (cons "DC1" (cons "DC2" (cons "DC3" (cons "DC4" (cons "NAK" (cons "SYN" (cons "ETB" (cons "CAN" (cons "EM" (cons "SUB" (cons "ESC" (cons "FS" (cons "GS" (cons "RS" (cons "US" '()))))))))))))))))))))))))))))))))))
(define PreludeC-45Show-showLitChar (lambda (arg-0) (cond ((equal? arg-0 (integer->char 7)) (lambda (arg-1) (string-append "\\a" arg-1))) ((equal? arg-0 (integer->char 8)) (lambda (arg-1) (string-append "\\b" arg-1))) ((equal? arg-0 (integer->char 12)) (lambda (arg-1) (string-append "\\f" arg-1))) ((equal? arg-0 (integer->char 10)) (lambda (arg-1) (string-append "\\n" arg-1))) ((equal? arg-0 (integer->char 13)) (lambda (arg-1) (string-append "\\r" arg-1))) ((equal? arg-0 (integer->char 9)) (lambda (arg-1) (string-append "\\t" arg-1))) ((equal? arg-0 (integer->char 11)) (lambda (arg-1) (string-append "\\v" arg-1))) ((equal? arg-0 (integer->char 14)) (lambda (eta-0) (PreludeC-45Show-protectEsc (lambda (arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-1 #\H)) "\\SO" eta-0))) ((equal? arg-0 (integer->char 127)) (lambda (arg-1) (string-append "\\DEL" arg-1))) ((equal? arg-0 #\\) (lambda (arg-1) (string-append "\\\\" arg-1)))(else (lambda (clam-0) (let ((sc0 (PreludeC-45Types-getAt (PreludeC-45Types-prim__integerToNat (char->integer arg-0)) (PreludeC-45Show-n--2434-11912-u--asciiTab arg-0)))) (if (null? sc0) (let ((sc1 (PreludeC-45EqOrd-u--C-62_Ord_Char arg-0 (integer->char 127)))) (cond ((equal? sc1 1) (string-cons #\\ (PreludeC-45Show-protectEsc (lambda (eta-0) (PreludeC-45Types-isDigit eta-0)) (PreludeC-45Show-u--show_Show_Int (cast-char-boundedInt arg-0 63)) clam-0))) (else (string-cons arg-0 clam-0)))) (let ((e-1 (unbox sc0))) (string-cons #\\ (string-append e-1 clam-0))))))))))
(define PreludeC-45Show-showLitString (lambda (arg-0) (lambda (clam-0) (if (null? arg-0) clam-0 (let ((e-2 (car arg-0))) (let ((e-3 (cdr arg-0))) (cond ((equal? e-2 #\") (string-append "\\\"" ((PreludeC-45Show-showLitString e-3) clam-0)))(else ((PreludeC-45Show-showLitChar e-2) ((PreludeC-45Show-showLitString e-3) clam-0))))))))))
(define PreludeC-45Show-u--show_Show_String (lambda (arg-0) (string-cons #\" ((PreludeC-45Show-showLitString (PreludeC-45Types-fastUnpack arg-0)) "\""))))
(define PreludeC-45Show-u--showPrec_Show_String (lambda (arg-0 arg-1) (PreludeC-45Show-u--show_Show_String arg-1)))
(define PreludeC-45Show-n--3216-12633-u--showC-39 (lambda (arg-1 arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (if (null? e-3) (string-append arg-3 (let ((e-1 (car arg-1))) (e-1 e-2))) (PreludeC-45Show-n--3216-12633-u--showC-39 arg-1 arg-2 (string-append arg-3 (string-append (let ((e-1 (car arg-1))) (e-1 e-2)) ", ")) e-3)))))))
(define PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (lambda (arg-1 arg-2) (string-append "[" (string-append (PreludeC-45Show-n--3216-12633-u--showC-39 arg-1 arg-2 "" arg-2) "]"))))
(define PreludeC-45Show-u--show_Show_Bool (lambda (arg-0) (cond ((equal? arg-0 1) "True") (else "False"))))
(define Ddraig-case--testFrontmatter-7730 (lambda (arg-0 arg-1) (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (lambda () (lambda (world-0) (let ((act-1 (PreludeC-45IO-prim__putStr (string-append (string-append "Title: " (let ((e-0 (vector-ref e-2 0))) e-0)) "\xa;") world-0))) (let ((act-2 (PreludeC-45IO-prim__putStr (string-append (string-append "Date: " (let ((e-1 (vector-ref e-2 1))) e-1)) "\xa;") world-0))) (let ((act-3 (PreludeC-45IO-prim__putStr (string-append (string-append "Tags: " (PreludeC-45Show-u--show_Show_C-40ListC-32C-36aC-41 (cons (lambda (u--x) (PreludeC-45Show-u--show_Show_String u--x)) (lambda (u--d) (lambda (u--x) (PreludeC-45Show-u--showPrec_Show_String u--d u--x)))) (let ((e-6 (vector-ref e-2 2))) e-6))) "\xa;") world-0))) (let ((act-4 (PreludeC-45IO-prim__putStr (string-append (string-append "Draft: " (PreludeC-45Show-u--show_Show_Bool (let ((e-5 (vector-ref e-2 3))) e-5))) "\xa;") world-0))) (PreludeC-45IO-prim__putStr (string-append (string-append "Body: " e-3) "\xa;") world-0)))))))))))
(define PreludeC-45TypesC-45SnocList-C-60C-62C-62 (lambda (arg-1 arg-2) (if (null? arg-1) arg-2 (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 e-2 (cons e-3 arg-2)))))))
(define PreludeC-45TypesC-45List-filterAppend (lambda (arg-1 arg-2 arg-3) (if (null? arg-3) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-1 '()) (let ((e-1 (car arg-3))) (let ((e-2 (cdr arg-3))) (let ((sc1 (arg-2 e-1))) (cond ((equal? sc1 1) (PreludeC-45TypesC-45List-filterAppend (cons arg-1 e-1) arg-2 e-2)) (else (PreludeC-45TypesC-45List-filterAppend arg-1 arg-2 e-2)))))))))
(define PreludeC-45TypesC-45String-length (lambda (arg-0) (PreludeC-45Types-prim__integerToNat (string-length arg-0))))
(define PreludeC-45TypesC-45List-mapAppend (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) (PreludeC-45TypesC-45SnocList-C-60C-62C-62 arg-2 '()) (let ((e-1 (car arg-4))) (let ((e-2 (cdr arg-4))) (PreludeC-45TypesC-45List-mapAppend (cons arg-2 (arg-3 e-1)) arg-3 e-2))))))
(define PreludeC-45Types-substr (lambda (arg-0 arg-1 arg-2) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Integer arg-0 (PreludeC-45TypesC-45String-length arg-2)))) (cond ((equal? sc0 1) (string-substr (blodwen-toSignedInt arg-0 63) (blodwen-toSignedInt arg-1 63) arg-2)) (else "")))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (or (and (string=? arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45Types-u--C-62_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 2)))
(define Ddraig-strHasPrefix (lambda (arg-0 arg-1) (let ((u--plen (PreludeC-45TypesC-45String-length arg-0))) (let ((u--slen (PreludeC-45TypesC-45String-length arg-1))) (let ((sc0 (PreludeC-45Types-u--C-62_Ord_Nat u--plen u--slen))) (cond ((equal? sc0 1) 0) (else (PreludeC-45EqOrd-u--C-61C-61_Eq_String (PreludeC-45Types-substr 0 u--plen arg-1) arg-0))))))))
(define PreludeC-45TypesC-45List-reverseOnto (lambda (arg-1 arg-2) (if (null? arg-2) arg-1 (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (PreludeC-45TypesC-45List-reverseOnto (cons e-2 arg-1) e-3))))))
(define PreludeC-45TypesC-45List-reverse (lambda (ext-0) (PreludeC-45TypesC-45List-reverseOnto '() ext-0)))
(define Ddraig-n--4366-5765-u--go (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (if (null? arg-2) (PreludeC-45TypesC-45List-reverse (cons (PreludeC-45Types-fastPack (PreludeC-45TypesC-45List-reverse arg-3)) arg-4)) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char e-2 arg-1))) (cond ((equal? sc1 1) (Ddraig-n--4366-5765-u--go arg-0 arg-1 e-3 '() (cons (PreludeC-45Types-fastPack (PreludeC-45TypesC-45List-reverse arg-3)) arg-4))) (else (Ddraig-n--4366-5765-u--go arg-0 arg-1 e-3 (cons e-2 arg-3) arg-4)))))))))
(define Ddraig-strSplitOn (lambda (arg-0 arg-1) (Ddraig-n--4366-5765-u--go arg-1 arg-0 (PreludeC-45Types-fastUnpack arg-1) '() '())))
(define DataC-45String-strM (lambda (arg-0) (cond ((equal? arg-0 "") '())(else (cons (string-ref arg-0 0) (substring arg-0 1 (string-length arg-0)))))))
(define DataC-45String-with--asList-9700 (lambda (arg-0 arg-1) (cond ((equal? arg-0 "") (if (null? arg-1) (vector 0 ) (let ((e-0 (car arg-1))) (let ((e-1 (cdr arg-1))) (vector 1 e-0 e-1 (lambda () (DataC-45String-asList e-1)))))))(else (let ((e-0 (car arg-1))) (let ((e-1 (cdr arg-1))) (vector 1 e-0 e-1 (lambda () (DataC-45String-asList e-1)))))))))
(define DataC-45String-asList (lambda (arg-0) (DataC-45String-with--asList-9700 arg-0 (DataC-45String-strM arg-0))))
(define PreludeC-45Types-isSpace (lambda (arg-0) (cond ((equal? arg-0 #\ ) 1) ((equal? arg-0 (integer->char 9)) 1) ((equal? arg-0 (integer->char 13)) 1) ((equal? arg-0 (integer->char 10)) 1) ((equal? arg-0 (integer->char 12)) 1) ((equal? arg-0 (integer->char 11)) 1) ((equal? arg-0 (integer->char 160)) 1)(else 0))))
(define DataC-45String-with--ltrim-9724 (lambda (arg-0 arg-1) (cond ((equal? arg-0 "") (case (vector-ref arg-1 0) ((0) "")(else (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (vector-ref arg-1 2))) (let ((e-2 (vector-ref arg-1 3))) (let ((u--str (string-cons e-0 e-1))) (let ((sc2 (PreludeC-45Types-isSpace e-0))) (cond ((equal? sc2 1) (DataC-45String-with--ltrim-9724 e-1 (e-2))) (else u--str))))))))))(else (let ((e-0 (vector-ref arg-1 1))) (let ((e-1 (vector-ref arg-1 2))) (let ((e-2 (vector-ref arg-1 3))) (let ((u--str (string-cons e-0 e-1))) (let ((sc1 (PreludeC-45Types-isSpace e-0))) (cond ((equal? sc1 1) (DataC-45String-with--ltrim-9724 e-1 (e-2))) (else u--str)))))))))))
(define DataC-45String-ltrim (lambda (arg-0) (DataC-45String-with--ltrim-9724 arg-0 (DataC-45String-asList arg-0))))
(define DataC-45String-trim (lambda (ext-0) (DataC-45String-ltrim (string-reverse (DataC-45String-ltrim (string-reverse ext-0))))))
(define Ddraig-case--parseFmLine-5902 (lambda (arg-0 arg-1 arg-2) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (if (null? e-3) arg-0 (let ((e-7 (cdr e-3))) (let ((u--key (DataC-45String-trim (PreludeC-45Types-fastPack e-2)))) (let ((u--value (DataC-45String-trim (PreludeC-45Types-fastPack e-7)))) (cond ((equal? u--key "title") (let ((e-1 (vector-ref arg-0 1))) (let ((e-8 (vector-ref arg-0 2))) (let ((e-5 (vector-ref arg-0 3))) (let ((e-4 (vector-ref arg-0 4))) (vector u--value e-1 e-8 e-5 e-4)))))) ((equal? u--key "date") (let ((e-0 (vector-ref arg-0 0))) (let ((e-8 (vector-ref arg-0 2))) (let ((e-5 (vector-ref arg-0 3))) (let ((e-4 (vector-ref arg-0 4))) (vector e-0 u--value e-8 e-5 e-4)))))) ((equal? u--key "template") (let ((e-0 (vector-ref arg-0 0))) (let ((e-1 (vector-ref arg-0 1))) (let ((e-8 (vector-ref arg-0 2))) (let ((e-5 (vector-ref arg-0 3))) (vector e-0 e-1 e-8 e-5 u--value)))))) ((equal? u--key "draft") (let ((e-0 (vector-ref arg-0 0))) (let ((e-1 (vector-ref arg-0 1))) (let ((e-8 (vector-ref arg-0 2))) (let ((e-4 (vector-ref arg-0 4))) (vector e-0 e-1 e-8 (let ((sc3 (PreludeC-45EqOrd-u--C-61C-61_Eq_String u--value "true"))) (cond ((equal? sc3 1) 1) (else (PreludeC-45EqOrd-u--C-61C-61_Eq_String u--value "yes")))) e-4)))))) ((equal? u--key "tags") (let ((u--tagStr (let ((sc3 (Ddraig-strHasPrefix "[" u--value))) (cond ((equal? sc3 1) (PreludeC-45Types-substr 1 (PreludeC-45Types-prim__integerToNat (- (PreludeC-45TypesC-45String-length u--value) 2)) u--value)) (else u--value))))) (let ((u--tagList (PreludeC-45TypesC-45List-mapAppend '() (lambda (eta-0) (DataC-45String-trim eta-0)) (Ddraig-strSplitOn #\, u--tagStr)))) (let ((e-0 (vector-ref arg-0 0))) (let ((e-1 (vector-ref arg-0 1))) (let ((e-5 (vector-ref arg-0 3))) (let ((e-4 (vector-ref arg-0 4))) (vector e-0 e-1 (PreludeC-45TypesC-45List-filterAppend '() (lambda (u--s) (PreludeC-45Types-u--C-62_Ord_Nat (PreludeC-45TypesC-45String-length u--s) 0)) u--tagList) e-5 e-4))))))))(else arg-0))))))))))
(define PreludeC-45Types-u--C-60_Ord_Nat (lambda (arg-0 arg-1) (PreludeC-45EqOrd-u--C-61C-61_Eq_Ordering (PreludeC-45EqOrd-u--compare_Ord_Integer arg-0 arg-1) 0)))
(define Ddraig-n--6320-7565-u--go (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (let ((sc0 (PreludeC-45Types-u--C-60_Ord_Nat (PreludeC-45TypesC-45String-length arg-3) (PreludeC-45TypesC-45String-length arg-1)))) (cond ((equal? sc0 1) (string-append arg-4 arg-3)) (else (let ((sc1 (Ddraig-strHasPrefix arg-1 arg-3))) (cond ((equal? sc1 1) (Ddraig-n--6320-7565-u--go arg-0 arg-1 arg-2 (PreludeC-45Types-substr (PreludeC-45TypesC-45String-length arg-1) (PreludeC-45TypesC-45String-length arg-3) arg-3) (string-append arg-4 arg-0))) (else (Ddraig-n--6320-7565-u--go arg-0 arg-1 arg-2 (PreludeC-45Types-substr 1 (PreludeC-45TypesC-45String-length arg-3) arg-3) (string-append arg-4 (PreludeC-45Types-substr 0 1 arg-3)))))))))))
(define DataC-45String-singleton (lambda (arg-0) (string-cons arg-0 "")))
(define DataC-45List-span (lambda (arg-1 arg-2) (if (null? arg-2) (cons '() '()) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (let ((sc1 (arg-1 e-2))) (cond ((equal? sc1 1) (let ((sc2 (DataC-45List-span arg-1 e-3))) (let ((e-5 (car sc2))) (let ((e-4 (cdr sc2))) (cons (cons e-2 e-5) e-4))))) (else (cons '() (cons e-2 e-3))))))))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Char (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define Ddraig-n--5230-6551-u--go (lambda (arg-0 arg-1 arg-2 arg-3 arg-4) (if (null? arg-1) arg-2 (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (cond ((equal? e-2 #\*) (if (null? e-3) (cond ((equal? arg-4 0) (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 "<em>") arg-3 1)) ((equal? arg-4 1) (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 "</em>") arg-3 0))(else (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 (DataC-45String-singleton e-2)) arg-3 arg-4))) (let ((e-5 (car e-3))) (let ((e-6 (cdr e-3))) (cond ((equal? e-5 #\*) (cond ((equal? arg-3 0) (Ddraig-n--5230-6551-u--go arg-0 e-6 (string-append arg-2 "<strong>") 1 arg-4)) ((equal? arg-3 1) (Ddraig-n--5230-6551-u--go arg-0 e-6 (string-append arg-2 "</strong>") 0 arg-4))(else (cond ((equal? arg-4 0) (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 "<em>") arg-3 1)) ((equal? arg-4 1) (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 "</em>") arg-3 0))(else (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 (DataC-45String-singleton e-2)) arg-3 arg-4))))))(else (cond ((equal? arg-4 0) (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 "<em>") arg-3 1)) ((equal? arg-4 1) (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 "</em>") arg-3 0))(else (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 (DataC-45String-singleton e-2)) arg-3 arg-4))))))))) ((equal? e-2 #\`) (let ((sc2 (DataC-45List-span (lambda (arg-5) (PreludeC-45EqOrd-u--C-47C-61_Eq_Char arg-5 #\`)) e-3))) (let ((e-5 (car sc2))) (let ((e-4 (cdr sc2))) (if (null? e-4) (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 "`") arg-3 arg-4) (let ((e-1 (car e-4))) (let ((e-6 (cdr e-4))) (cond ((equal? e-1 #\`) (Ddraig-n--5230-6551-u--go arg-0 e-6 (string-append arg-2 (string-append "<code>" (string-append (PreludeC-45Types-fastPack e-5) "</code>"))) arg-3 arg-4))(else (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 "`") arg-3 arg-4))))))))))(else (Ddraig-n--5230-6551-u--go arg-0 e-3 (string-append arg-2 (DataC-45String-singleton e-2)) arg-3 arg-4))))))))
(define DataC-45String-n--3856-9432-u--unlinesC-39 (lambda (arg-0) (if (null? arg-0) '() (let ((e-2 (car arg-0))) (let ((e-3 (cdr arg-0))) (cons e-2 (cons "\xa;" (DataC-45String-n--3856-9432-u--unlinesC-39 e-3))))))))
(define DataC-45String-fastUnlines (lambda (ext-0) (PreludeC-45Types-fastConcat (DataC-45String-n--3856-9432-u--unlinesC-39 ext-0))))
(define DataC-45List-break (lambda (arg-1 arg-2) (DataC-45List-span (lambda (eta-0) (let ((sc0 (arg-1 eta-0))) (cond ((equal? sc0 1) 0) (else 1)))) arg-2)))
(define Ddraig-parseFmLine (lambda (arg-0 arg-1) (Ddraig-case--parseFmLine-5902 arg-1 arg-0 (DataC-45List-break (lambda (arg-2) (PreludeC-45EqOrd-u--C-61C-61_Eq_Char arg-2 #\:)) (PreludeC-45Types-fastUnpack arg-0)))))
(define Ddraig-n--4890-6236-u--findEnd (lambda (arg-0 arg-1 arg-2) (if (null? arg-1) (cons arg-2 "") (let ((e-2 (car arg-1))) (let ((e-3 (cdr arg-1))) (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_String (DataC-45String-trim e-2) "---"))) (cond ((equal? sc1 1) (cons arg-2 (DataC-45String-fastUnlines e-3))) (else (Ddraig-n--4890-6236-u--findEnd arg-0 e-3 (Ddraig-parseFmLine e-2 arg-2))))))))))
(define Ddraig-n--4456-5844-u--esc (lambda (arg-0 arg-1) (cond ((equal? arg-1 #\<) "&lt;") ((equal? arg-1 #\>) "&gt;") ((equal? arg-1 #\&) "&amp;") ((equal? arg-1 #\") "&quot;")(else (DataC-45String-singleton arg-1)))))
(define Ddraig-closePara (lambda (arg-0) (let ((sc0 (let ((e-1 (vector-ref arg-0 1))) e-1))) (cond ((equal? sc0 1) (let ((e-0 (vector-ref arg-0 0))) (let ((e-2 (vector-ref arg-0 2))) (let ((e-3 (vector-ref arg-0 3))) (let ((e-4 (vector-ref arg-0 4))) (vector (string-append e-0 "</p>\xa;") 0 e-2 e-3 e-4)))))) (else arg-0)))))
(define Ddraig-closeUl (lambda (arg-0) (let ((sc0 (let ((e-3 (vector-ref arg-0 3))) e-3))) (cond ((equal? sc0 1) (let ((u--tag (let ((sc1 (let ((e-4 (vector-ref arg-0 4))) e-4))) (cond ((equal? sc1 1) "</ol>\xa;") (else "</ul>\xa;"))))) (let ((e-0 (vector-ref arg-0 0))) (let ((e-1 (vector-ref arg-0 1))) (let ((e-2 (vector-ref arg-0 2))) (let ((e-4 (vector-ref arg-0 4))) (vector (string-append e-0 u--tag) e-1 e-2 0 e-4))))))) (else arg-0)))))
(define Ddraig-doInline (lambda (arg-0) (Ddraig-n--5230-6551-u--go arg-0 (PreludeC-45Types-fastUnpack arg-0) "" 0 0)))
(define Ddraig-strDropPrefix (lambda (arg-0 arg-1) (let ((sc0 (Ddraig-strHasPrefix arg-0 arg-1))) (cond ((equal? sc0 1) (PreludeC-45Types-substr (PreludeC-45TypesC-45String-length arg-0) (PreludeC-45TypesC-45String-length arg-1) arg-1)) (else arg-1)))))
(define PreludeC-45Types-u--foldl_Foldable_List (lambda (arg-2 arg-3 arg-4) (if (null? arg-4) arg-3 (let ((e-2 (car arg-4))) (let ((e-3 (cdr arg-4))) (PreludeC-45Types-u--foldl_Foldable_List arg-2 ((arg-2 arg-3) e-2) e-3))))))
(define PreludeC-45Types-u--foldMap_Foldable_List (lambda (arg-2 arg-3 ext-0) (PreludeC-45Types-u--foldl_Foldable_List (lambda (u--acc) (lambda (u--elem) (let ((e-1 (car arg-2))) ((e-1 u--acc) (arg-3 u--elem))))) (let ((e-2 (cdr arg-2))) e-2) ext-0)))
(define Ddraig-strEscape (lambda (arg-0) (PreludeC-45Types-u--foldMap_Foldable_List (cons (lambda (arg-8505) (lambda (arg-8508) (string-append arg-8505 arg-8508))) "") (lambda (eta-0) eta-0) (PreludeC-45TypesC-45List-mapAppend '() (lambda (eta-0) (Ddraig-n--4456-5844-u--esc arg-0 eta-0)) (PreludeC-45Types-fastUnpack arg-0)))))
(define Ddraig-doLine (lambda (arg-0 arg-1) (let ((u--tr (DataC-45String-trim arg-0))) (let ((sc0 (Ddraig-strHasPrefix "```" u--tr))) (cond ((equal? sc0 1) (let ((sc1 (let ((e-2 (vector-ref arg-1 2))) e-2))) (cond ((equal? sc1 1) (let ((e-0 (vector-ref arg-1 0))) (let ((e-1 (vector-ref arg-1 1))) (let ((e-3 (vector-ref arg-1 3))) (let ((e-4 (vector-ref arg-1 4))) (vector (string-append e-0 "</code></pre>\xa;") e-1 0 e-3 e-4)))))) (else (let ((u--st1 (Ddraig-closeUl (Ddraig-closePara arg-1)))) (let ((e-0 (vector-ref u--st1 0))) (let ((e-1 (vector-ref u--st1 1))) (let ((e-3 (vector-ref u--st1 3))) (let ((e-4 (vector-ref u--st1 4))) (vector (string-append e-0 "<pre><code>") e-1 1 e-3 e-4)))))))))) (else (let ((sc1 (let ((e-2 (vector-ref arg-1 2))) e-2))) (cond ((equal? sc1 1) (let ((e-0 (vector-ref arg-1 0))) (let ((e-1 (vector-ref arg-1 1))) (let ((e-2 (vector-ref arg-1 2))) (let ((e-3 (vector-ref arg-1 3))) (let ((e-4 (vector-ref arg-1 4))) (vector (string-append e-0 (string-append (Ddraig-strEscape arg-0) "\xa;")) e-1 e-2 e-3 e-4))))))) (else (let ((sc2 (PreludeC-45EqOrd-u--C-61C-61_Eq_String u--tr ""))) (cond ((equal? sc2 1) (Ddraig-closeUl (Ddraig-closePara arg-1))) (else (let ((sc3 (Ddraig-strHasPrefix "######" u--tr))) (cond ((equal? sc3 1) (let ((u--st1 (Ddraig-closeUl (Ddraig-closePara arg-1)))) (let ((u--c (Ddraig-doInline (DataC-45String-trim (Ddraig-strDropPrefix "######" u--tr))))) (let ((e-0 (vector-ref u--st1 0))) (let ((e-1 (vector-ref u--st1 1))) (let ((e-2 (vector-ref u--st1 2))) (let ((e-3 (vector-ref u--st1 3))) (let ((e-4 (vector-ref u--st1 4))) (vector (string-append e-0 (string-append "<h6>" (string-append u--c "</h6>\xa;"))) e-1 e-2 e-3 e-4))))))))) (else (let ((sc4 (Ddraig-strHasPrefix "#####" u--tr))) (cond ((equal? sc4 1) (let ((u--st1 (Ddraig-closeUl (Ddraig-closePara arg-1)))) (let ((u--c (Ddraig-doInline (DataC-45String-trim (Ddraig-strDropPrefix "#####" u--tr))))) (let ((e-0 (vector-ref u--st1 0))) (let ((e-1 (vector-ref u--st1 1))) (let ((e-2 (vector-ref u--st1 2))) (let ((e-3 (vector-ref u--st1 3))) (let ((e-4 (vector-ref u--st1 4))) (vector (string-append e-0 (string-append "<h5>" (string-append u--c "</h5>\xa;"))) e-1 e-2 e-3 e-4))))))))) (else (let ((sc5 (Ddraig-strHasPrefix "####" u--tr))) (cond ((equal? sc5 1) (let ((u--st1 (Ddraig-closeUl (Ddraig-closePara arg-1)))) (let ((u--c (Ddraig-doInline (DataC-45String-trim (Ddraig-strDropPrefix "####" u--tr))))) (let ((e-0 (vector-ref u--st1 0))) (let ((e-1 (vector-ref u--st1 1))) (let ((e-2 (vector-ref u--st1 2))) (let ((e-3 (vector-ref u--st1 3))) (let ((e-4 (vector-ref u--st1 4))) (vector (string-append e-0 (string-append "<h4>" (string-append u--c "</h4>\xa;"))) e-1 e-2 e-3 e-4))))))))) (else (let ((sc6 (Ddraig-strHasPrefix "###" u--tr))) (cond ((equal? sc6 1) (let ((u--st1 (Ddraig-closeUl (Ddraig-closePara arg-1)))) (let ((u--c (Ddraig-doInline (DataC-45String-trim (Ddraig-strDropPrefix "###" u--tr))))) (let ((e-0 (vector-ref u--st1 0))) (let ((e-1 (vector-ref u--st1 1))) (let ((e-2 (vector-ref u--st1 2))) (let ((e-3 (vector-ref u--st1 3))) (let ((e-4 (vector-ref u--st1 4))) (vector (string-append e-0 (string-append "<h3>" (string-append u--c "</h3>\xa;"))) e-1 e-2 e-3 e-4))))))))) (else (let ((sc7 (Ddraig-strHasPrefix "##" u--tr))) (cond ((equal? sc7 1) (let ((u--st1 (Ddraig-closeUl (Ddraig-closePara arg-1)))) (let ((u--c (Ddraig-doInline (DataC-45String-trim (Ddraig-strDropPrefix "##" u--tr))))) (let ((e-0 (vector-ref u--st1 0))) (let ((e-1 (vector-ref u--st1 1))) (let ((e-2 (vector-ref u--st1 2))) (let ((e-3 (vector-ref u--st1 3))) (let ((e-4 (vector-ref u--st1 4))) (vector (string-append e-0 (string-append "<h2>" (string-append u--c "</h2>\xa;"))) e-1 e-2 e-3 e-4))))))))) (else (let ((sc8 (Ddraig-strHasPrefix "#" u--tr))) (cond ((equal? sc8 1) (let ((u--st1 (Ddraig-closeUl (Ddraig-closePara arg-1)))) (let ((u--c (Ddraig-doInline (DataC-45String-trim (Ddraig-strDropPrefix "#" u--tr))))) (let ((e-0 (vector-ref u--st1 0))) (let ((e-1 (vector-ref u--st1 1))) (let ((e-2 (vector-ref u--st1 2))) (let ((e-3 (vector-ref u--st1 3))) (let ((e-4 (vector-ref u--st1 4))) (vector (string-append e-0 (string-append "<h1>" (string-append u--c "</h1>\xa;"))) e-1 e-2 e-3 e-4))))))))) (else (let ((sc9 (let ((sc10 (Ddraig-strHasPrefix "- " u--tr))) (cond ((equal? sc10 1) 1) (else (Ddraig-strHasPrefix "* " u--tr)))))) (cond ((equal? sc9 1) (let ((u--st1 (Ddraig-closePara arg-1))) (let ((u--st2 (let ((sc10 (let ((sc11 (let ((e-3 (vector-ref u--st1 3))) e-3))) (cond ((equal? sc11 1) (let ((e-4 (vector-ref u--st1 4))) e-4)) (else 0))))) (cond ((equal? sc10 1) (Ddraig-closeUl u--st1)) (else u--st1))))) (let ((u--st3 (let ((sc10 (let ((e-3 (vector-ref u--st2 3))) e-3))) (cond ((equal? sc10 1) u--st2) (else (let ((e-0 (vector-ref u--st2 0))) (let ((e-1 (vector-ref u--st2 1))) (let ((e-2 (vector-ref u--st2 2))) (vector (string-append e-0 "<ul>\xa;") e-1 e-2 1 0))))))))) (let ((u--item (Ddraig-doInline (DataC-45String-trim (PreludeC-45Types-substr 2 (PreludeC-45TypesC-45String-length u--tr) u--tr))))) (let ((e-0 (vector-ref u--st3 0))) (let ((e-1 (vector-ref u--st3 1))) (let ((e-2 (vector-ref u--st3 2))) (let ((e-3 (vector-ref u--st3 3))) (let ((e-4 (vector-ref u--st3 4))) (vector (string-append e-0 (string-append "<li>" (string-append u--item "</li>\xa;"))) e-1 e-2 e-3 e-4))))))))))) (else (let ((u--st1 (let ((sc10 (let ((e-1 (vector-ref arg-1 1))) e-1))) (cond ((equal? sc10 1) (let ((e-0 (vector-ref arg-1 0))) (let ((e-1 (vector-ref arg-1 1))) (let ((e-2 (vector-ref arg-1 2))) (let ((e-3 (vector-ref arg-1 3))) (let ((e-4 (vector-ref arg-1 4))) (vector (string-append e-0 " ") e-1 e-2 e-3 e-4))))))) (else (let ((e-0 (vector-ref arg-1 0))) (let ((e-2 (vector-ref arg-1 2))) (let ((e-3 (vector-ref arg-1 3))) (let ((e-4 (vector-ref arg-1 4))) (vector (string-append e-0 "<p>") 1 e-2 e-3 e-4)))))))))) (let ((e-0 (vector-ref u--st1 0))) (let ((e-1 (vector-ref u--st1 1))) (let ((e-2 (vector-ref u--st1 2))) (let ((e-3 (vector-ref u--st1 3))) (let ((e-4 (vector-ref u--st1 4))) (vector (string-append e-0 (Ddraig-doInline u--tr)) e-1 e-2 e-3 e-4))))))))))))))))))))))))))))))))))))))))
(define PreludeC-45Basics-flip (lambda (arg-3 ext-0 ext-1) ((arg-3 ext-1) ext-0)))
(define Ddraig-initState (vector "" 0 0 0 0))
(define DataC-45String-n--3989-9562-u--linesHelp (lambda (arg-0 arg-1 arg-2) (if (null? arg-1) (if (null? arg-2) '() (if (null? arg-2) (cons (PreludeC-45TypesC-45List-reverse arg-1) '()) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cond ((equal? e-2 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3989-9562-u--linesHelp arg-0 '() e-3))) ((equal? e-2 (integer->char 13)) (if (null? e-3) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3989-9562-u--linesHelp arg-0 '() e-3)) (let ((e-5 (car e-3))) (let ((e-6 (cdr e-3))) (cond ((equal? e-5 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3989-9562-u--linesHelp arg-0 '() e-6)))(else (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3989-9562-u--linesHelp arg-0 '() e-3))))))))(else (DataC-45String-n--3989-9562-u--linesHelp arg-0 (cons e-2 arg-1) e-3))))))) (if (null? arg-2) (cons (PreludeC-45TypesC-45List-reverse arg-1) '()) (let ((e-2 (car arg-2))) (let ((e-3 (cdr arg-2))) (cond ((equal? e-2 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3989-9562-u--linesHelp arg-0 '() e-3))) ((equal? e-2 (integer->char 13)) (if (null? e-3) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3989-9562-u--linesHelp arg-0 '() e-3)) (let ((e-5 (car e-3))) (let ((e-6 (cdr e-3))) (cond ((equal? e-5 (integer->char 10)) (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3989-9562-u--linesHelp arg-0 '() e-6)))(else (cons (PreludeC-45TypesC-45List-reverse arg-1) (DataC-45String-n--3989-9562-u--linesHelp arg-0 '() e-3))))))))(else (DataC-45String-n--3989-9562-u--linesHelp arg-0 (cons e-2 arg-1) e-3)))))))))
(define DataC-45String-linesC-39 (lambda (arg-0) (DataC-45String-n--3989-9562-u--linesHelp arg-0 '() arg-0)))
(define DataC-45String-lines (lambda (arg-0) (PreludeC-45TypesC-45List-mapAppend '() (lambda (eta-0) (PreludeC-45Types-fastPack eta-0)) (DataC-45String-linesC-39 (PreludeC-45Types-fastUnpack arg-0)))))
(define Ddraig-parseMarkdown (lambda (arg-0) (let ((u--allLines (DataC-45String-lines arg-0))) (let ((u--final (PreludeC-45Types-u--foldl_Foldable_List (lambda (eta-0) (lambda (eta-1) (PreludeC-45Basics-flip (lambda (eta-2) (lambda (eta-3) (Ddraig-doLine eta-2 eta-3))) eta-0 eta-1))) Ddraig-initState u--allLines))) (let ((u--st1 (Ddraig-closeUl (Ddraig-closePara u--final)))) (let ((u--st2 (let ((sc0 (let ((e-2 (vector-ref u--st1 2))) e-2))) (cond ((equal? sc0 1) (let ((e-0 (vector-ref u--st1 0))) (let ((e-1 (vector-ref u--st1 1))) (let ((e-2 (vector-ref u--st1 2))) (let ((e-3 (vector-ref u--st1 3))) (let ((e-4 (vector-ref u--st1 4))) (vector (string-append e-0 "</code></pre>\xa;") e-1 e-2 e-3 e-4))))))) (else u--st1))))) (let ((e-0 (vector-ref u--st2 0))) e-0)))))))
(define Ddraig-testMarkdown (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "=== Test: Markdown ===\xa;" ext-0))) (PreludeC-45IO-prim__putStr (string-append (Ddraig-parseMarkdown "# Hello World\xa;\xa;This is a **bold** test with *italic* text.\xa;\xa;- Item 1\xa;- Item 2\xa;\xa;```\xa;code block\xa;```\xa;") "\xa;") ext-0))))
(define Ddraig-defTemplate "<!DOCTYPE html>\xa;<html><head><meta charset=\"UTF-8\"><title>{{title}}</title><style>body{font-family:system-ui;max-width:800px;margin:0 auto;padding:2rem}pre{background:#f4f4f4;padding:1rem}</style></head><body><article><h1>{{title}}</h1><time>{{date}}</time>{{content}}</article></body></html>")
(define Ddraig-strReplace (lambda (arg-0 arg-1 arg-2) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-1 ""))) (cond ((equal? sc0 1) arg-0) (else (Ddraig-n--6320-7565-u--go arg-2 arg-1 arg-0 arg-0 ""))))))
(define Ddraig-applyTemplate (lambda (arg-0 arg-1) (let ((u--t1 (Ddraig-strReplace Ddraig-defTemplate "{{title}}" (let ((e-0 (vector-ref arg-0 0))) e-0)))) (let ((u--t2 (Ddraig-strReplace u--t1 "{{date}}" (let ((e-1 (vector-ref arg-0 1))) e-1)))) (Ddraig-strReplace u--t2 "{{content}}" arg-1)))))
(define Ddraig-emptyFrontmatter (vector "" "" '() 0 "default"))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_String (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_String arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define Ddraig-parseFrontmatter (lambda (arg-0) (let ((u--allLines (DataC-45String-lines arg-0))) (if (null? u--allLines) (cons Ddraig-emptyFrontmatter arg-0) (let ((e-2 (car u--allLines))) (let ((e-3 (cdr u--allLines))) (let ((sc1 (PreludeC-45EqOrd-u--C-47C-61_Eq_String (DataC-45String-trim e-2) "---"))) (cond ((equal? sc1 1) (cons Ddraig-emptyFrontmatter arg-0)) (else (Ddraig-n--4890-6236-u--findEnd arg-0 e-3 Ddraig-emptyFrontmatter))))))))))
(define Ddraig-testFull (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "=== Test: Full Pipeline ===\xa;" ext-0))) (((let ((sc0 (Ddraig-parseFrontmatter "---\xa;title: Welcome\xa;date: 2024-01-15\xa;---\xa;\xa;# Welcome\xa;\xa;This is **Ddraig**, an Idris 2-powered SSG.\xa;\xa;- Dependently typed\xa;- Provably correct\xa;- Elegant\xa;"))) (let ((e-2 (car sc0))) (let ((e-3 (cdr sc0))) (let ((u--htmlOut (Ddraig-parseMarkdown e-3))) (let ((u--output (Ddraig-applyTemplate e-2 u--htmlOut))) (lambda () (lambda (eta-0) (PreludeC-45IO-prim__putStr (string-append u--output "\xa;") eta-0))))))))) ext-0))))
(define Ddraig-testFrontmatter (lambda (ext-0) (let ((act-1 (PreludeC-45IO-prim__putStr "=== Test: Frontmatter ===\xa;" ext-0))) (((Ddraig-case--testFrontmatter-7730 "---\xa;title: My Post\xa;date: 2024-01-15\xa;tags: [idris, ssg]\xa;draft: false\xa;---\xa;\xa;Content here\xa;" (Ddraig-parseFrontmatter "---\xa;title: My Post\xa;date: 2024-01-15\xa;tags: [idris, ssg]\xa;draft: false\xa;---\xa;\xa;Content here\xa;"))) ext-0))))
(define PreludeC-45EqOrd-u--C-61C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-47C-61_Eq_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else 1)))))
(define PreludeC-45EqOrd-u--C-60C-61_Ord_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (<= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-60_Ord_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (< arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62C-61_Ord_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (>= arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--C-62_Ord_Int (lambda (arg-0 arg-1) (let ((sc0 (or (and (> arg-0 arg-1) 1) 0))) (cond ((equal? sc0 0) 0)(else 1)))))
(define PreludeC-45EqOrd-u--compare_Ord_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Int arg-0 arg-1))) (cond ((equal? sc0 1) 0) (else (let ((sc1 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-0 arg-1))) (cond ((equal? sc1 1) 1) (else 2))))))))
(define PreludeC-45Num-u--div_Integral_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-1 (blodwen-toSignedInt 0 63)))) (cond ((equal? sc0 0) (bs/ arg-0 arg-1 63))(else (blodwen-error-quit (string-append "ERROR: " "Unhandled input for Prelude.Num.case block in div at Prelude.Num:128:3--130:40")))))))
(define PreludeC-45EqOrd-u--max_Ord_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-62_Ord_Int arg-0 arg-1))) (cond ((equal? sc0 1) arg-0) (else arg-1)))))
(define PreludeC-45EqOrd-u--min_Ord_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-60_Ord_Int arg-0 arg-1))) (cond ((equal? sc0 1) arg-0) (else arg-1)))))
(define PreludeC-45Num-u--mod_Integral_Int (lambda (arg-0 arg-1) (let ((sc0 (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-1 (blodwen-toSignedInt 0 63)))) (cond ((equal? sc0 0) (blodwen-euclidMod arg-0 arg-1))(else (blodwen-error-quit (string-append "ERROR: " "Unhandled input for Prelude.Num.case block in mod at Prelude.Num:131:3--133:40")))))))
(define PreludeC-45Types-countFrom (lambda (arg-1 arg-2) (cons arg-1 (lambda () (PreludeC-45Types-countFrom (arg-2 arg-1) arg-2)))))
(define Builtin-fst (lambda (arg-2) (let ((e-2 (car arg-2))) e-2)))
(define Builtin-snd (lambda (arg-2) (let ((e-3 (cdr arg-2))) e-3)))
(define PreludeC-45Types-takeUntil (lambda (arg-1 arg-2) (let ((e-1 (car arg-2))) (let ((e-2 (cdr arg-2))) (let ((sc1 (arg-1 e-1))) (cond ((equal? sc1 1) (cons e-1 '())) (else (cons e-1 (PreludeC-45Types-takeUntil arg-1 (e-2))))))))))
(define PreludeC-45Types-u--pure_Applicative_List (lambda (arg-1) (cons arg-1 '())))
(define PreludeC-45Types-u--rangeFromTo_Range_C-36a (lambda (arg-1 arg-2 arg-3) (let ((sc0 (let ((sc1 (Builtin-fst (Builtin-snd arg-1)))) (let ((e-2 (vector-ref sc1 1))) ((e-2 arg-2) arg-3))))) (cond ((equal? sc0 0) (PreludeC-45Types-takeUntil (lambda (arg-0) (let ((sc1 (Builtin-fst (Builtin-snd arg-1)))) (let ((e-6 (vector-ref sc1 5))) ((e-6 arg-0) arg-3)))) (PreludeC-45Types-countFrom arg-2 (lambda (arg-0) (let ((sc1 (Builtin-snd (Builtin-snd arg-1)))) (let ((e-1 (vector-ref sc1 0))) (let ((e-6 (vector-ref e-1 0))) ((e-6 arg-0) (let ((sc1 (Builtin-snd (Builtin-snd arg-1)))) (let ((e-9 (vector-ref sc1 0))) (let ((e-10 (vector-ref e-9 2))) (e-10 1)))))))))))) ((equal? sc0 1) (PreludeC-45Types-u--pure_Applicative_List arg-2)) (else (PreludeC-45Types-takeUntil (lambda (arg-0) (let ((sc1 (Builtin-fst (Builtin-snd arg-1)))) (let ((e-5 (vector-ref sc1 4))) ((e-5 arg-0) arg-3)))) (PreludeC-45Types-countFrom arg-2 (lambda (u--x) (let ((sc1 (Builtin-snd (Builtin-snd arg-1)))) (let ((e-3 (vector-ref sc1 2))) ((e-3 u--x) (let ((sc1 (Builtin-snd (Builtin-snd arg-1)))) (let ((e-6 (vector-ref sc1 0))) (let ((e-7 (vector-ref e-6 2))) (e-7 1)))))))))))))))
(define PreludeC-45Types-u--traverse_Traversable_List (lambda (arg-3 arg-4 arg-5) (if (null? arg-5) (let ((e-2 (vector-ref arg-3 1))) ((e-2 'erased) '())) (let ((e-2 (car arg-5))) (let ((e-3 (cdr arg-5))) (let ((e-4 (vector-ref arg-3 2))) ((((e-4 'erased) 'erased) (let ((e-6 (vector-ref arg-3 2))) ((((e-6 'erased) 'erased) (let ((e-10 (vector-ref arg-3 1))) ((e-10 'erased) (lambda (eta-0) (lambda (eta-1) (cons eta-0 eta-1)))))) (arg-4 e-2)))) (PreludeC-45Types-u--traverse_Traversable_List arg-3 arg-4 e-3))))))))
(define System-getArgs (lambda (arg-1) (let ((e-1 (car arg-1))) (let ((e-4 (vector-ref e-1 1))) ((((e-4 'erased) 'erased) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-0) (System-prim__getArgCount eta-0))))) (lambda (u--n) (let ((sc1 (PreludeC-45EqOrd-u--C-62_Ord_Int u--n (blodwen-toSignedInt 0 63)))) (cond ((equal? sc1 1) (PreludeC-45Basics-flip (lambda (arg-14099) (lambda (arg-14106) (PreludeC-45Types-u--traverse_Traversable_List (let ((e-7 (car arg-1))) (let ((e-10 (vector-ref e-7 0))) e-10)) arg-14099 arg-14106))) (PreludeC-45Types-u--rangeFromTo_Range_C-36a (cons (vector csegen-65 (lambda (arg-6342) (lambda (arg-6345) (PreludeC-45Num-u--div_Integral_Int arg-6342 arg-6345))) (lambda (arg-6352) (lambda (arg-6355) (PreludeC-45Num-u--mod_Integral_Int arg-6352 arg-6355)))) (cons (vector (cons (lambda (arg-712) (lambda (arg-715) (PreludeC-45EqOrd-u--C-61C-61_Eq_Int arg-712 arg-715))) (lambda (arg-722) (lambda (arg-725) (PreludeC-45EqOrd-u--C-47C-61_Eq_Int arg-722 arg-725)))) (lambda (arg-1598) (lambda (arg-1601) (PreludeC-45EqOrd-u--compare_Ord_Int arg-1598 arg-1601))) (lambda (arg-1608) (lambda (arg-1611) (PreludeC-45EqOrd-u--C-60_Ord_Int arg-1608 arg-1611))) (lambda (arg-1618) (lambda (arg-1621) (PreludeC-45EqOrd-u--C-62_Ord_Int arg-1618 arg-1621))) (lambda (arg-1628) (lambda (arg-1631) (PreludeC-45EqOrd-u--C-60C-61_Ord_Int arg-1628 arg-1631))) (lambda (arg-1638) (lambda (arg-1641) (PreludeC-45EqOrd-u--C-62C-61_Ord_Int arg-1638 arg-1641))) (lambda (arg-1648) (lambda (arg-1651) (PreludeC-45EqOrd-u--max_Ord_Int arg-1648 arg-1651))) (lambda (arg-1658) (lambda (arg-1661) (PreludeC-45EqOrd-u--min_Ord_Int arg-1658 arg-1661)))) (vector csegen-65 (lambda (arg-6042) (bs- 0 arg-6042 63)) (lambda (arg-6048) (lambda (arg-6051) (bs- arg-6048 arg-6051 63)))))) 0 (bs- u--n 1 63)) (lambda (eta-0) (let ((e-6 (cdr arg-1))) ((e-6 'erased) (lambda (eta-1) (System-prim__getArg eta-0 eta-1))))))) (else (let ((e-7 (car arg-1))) (let ((e-10 (vector-ref e-7 0))) (let ((e-12 (vector-ref e-10 1))) ((e-12 'erased) '())))))))))))))
(define PreludeC-45IO-u--map_Functor_IO (lambda (arg-2 arg-3 ext-0) (let ((act-2 (arg-3 ext-0))) (arg-2 act-2))))
(define Ddraig-main (lambda (ext-0) (let ((act-1 ((System-getArgs (cons (vector (vector (lambda (u--b) (lambda (u--a) (lambda (u--func) (lambda (arg-8920) (lambda (eta-0) (PreludeC-45IO-u--map_Functor_IO u--func arg-8920 eta-0)))))) (lambda (u--a) (lambda (arg-9959) (lambda (eta-0) arg-9959))) (lambda (u--b) (lambda (u--a) (lambda (arg-9965) (lambda (arg-9972) (lambda (world-4) (let ((act-5 (arg-9965 world-4))) (let ((act-3 (arg-9972 world-4))) (act-5 act-3))))))))) (lambda (u--b) (lambda (u--a) (lambda (arg-10444) (lambda (arg-10447) (lambda (world-0) (let ((act-1 (arg-10444 world-0))) ((arg-10447 act-1) world-0))))))) (lambda (u--a) (lambda (arg-10458) (lambda (world-0) (let ((act-1 (arg-10458 world-0))) (act-1 world-0)))))) (lambda (u--a) (lambda (arg-13076) arg-13076)))) ext-0))) (if (null? act-1) (let ((act-2 (PreludeC-45IO-prim__putStr "Ddraig SSG - Idris 2 powered\xa;" ext-0))) (PreludeC-45IO-prim__putStr "Commands: test-markdown test-frontmatter test-full\xa;" ext-0)) (let ((e-2 (cdr act-1))) (if (null? e-2) (let ((act-2 (PreludeC-45IO-prim__putStr "Ddraig SSG - Idris 2 powered\xa;" ext-0))) (PreludeC-45IO-prim__putStr "Commands: test-markdown test-frontmatter test-full\xa;" ext-0)) (let ((e-4 (car e-2))) (let ((e-5 (cdr e-2))) (cond ((equal? e-4 "test-markdown") (if (null? e-5) (Ddraig-testMarkdown ext-0) (let ((act-2 (PreludeC-45IO-prim__putStr "Ddraig SSG - Idris 2 powered\xa;" ext-0))) (PreludeC-45IO-prim__putStr "Commands: test-markdown test-frontmatter test-full\xa;" ext-0)))) ((equal? e-4 "test-frontmatter") (if (null? e-5) (Ddraig-testFrontmatter ext-0) (let ((act-2 (PreludeC-45IO-prim__putStr "Ddraig SSG - Idris 2 powered\xa;" ext-0))) (PreludeC-45IO-prim__putStr "Commands: test-markdown test-frontmatter test-full\xa;" ext-0)))) ((equal? e-4 "test-full") (if (null? e-5) (Ddraig-testFull ext-0) (let ((act-2 (PreludeC-45IO-prim__putStr "Ddraig SSG - Idris 2 powered\xa;" ext-0))) (PreludeC-45IO-prim__putStr "Commands: test-markdown test-frontmatter test-full\xa;" ext-0))))(else (let ((act-2 (PreludeC-45IO-prim__putStr "Ddraig SSG - Idris 2 powered\xa;" ext-0))) (PreludeC-45IO-prim__putStr "Commands: test-markdown test-frontmatter test-full\xa;" ext-0))))))))))))
(define PreludeC-45EqOrd-compareInteger (lambda (ext-0 ext-1) (PreludeC-45EqOrd-u--compare_Ord_Integer ext-0 ext-1)))
(define PrimIO-unsafeCreateWorld (lambda (arg-1) (arg-1 #f)))
(define PrimIO-unsafePerformIO (lambda (arg-1) (PrimIO-unsafeCreateWorld (lambda (u--w) (arg-1 u--w)))))
(collect-request-handler
  (let* ([gc-counter 1]
         [log-radix 2]
         [radix-mask (sub1 (bitwise-arithmetic-shift 1 log-radix))]
         [major-gc-factor 2]
         [trigger-major-gc-allocated (* major-gc-factor (bytes-allocated))])
    (lambda ()
      (cond
        [(>= (bytes-allocated) trigger-major-gc-allocated)
         ;; Force a major collection if memory use has doubled
         (collect (collect-maximum-generation))
         (blodwen-run-finalisers)
         (set! trigger-major-gc-allocated (* major-gc-factor (bytes-allocated)))]
        [else
         ;; Imitate the built-in rule, but without ever going to a major collection
         (let ([this-counter gc-counter])
           (if (> (add1 this-counter)
                  (bitwise-arithmetic-shift-left 1 (* log-radix (sub1 (collect-maximum-generation)))))
               (set! gc-counter 1)
               (set! gc-counter (add1 this-counter)))
           (collect
            ;; Find the minor generation implied by the counter
            (let loop ([c this-counter] [gen 0])
              (cond
                [(zero? (bitwise-and c radix-mask))
                 (loop (bitwise-arithmetic-shift-right c log-radix)
                       (add1 gen))]
                [else
                 gen]))))]))))
(PrimIO-unsafePerformIO (lambda (eta-0) (Ddraig-main eta-0)))
  (collect-request-handler (lambda () (collect (collect-maximum-generation)) (blodwen-run-finalisers)))
  (collect-rendezvous)
  
  )