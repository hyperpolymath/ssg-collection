# SPDX-License-Identifier: AGPL-3.0-or-later
# SPDX-FileCopyrightText: 2025 hyperpolymath
#
# baremetal-ssg - x86-64 Assembly Static Site Generator
# "Let registers compute. Let syscalls execute. Let sites emerge."
#
# Assemble: as -o baremetal.o baremetal.s && ld -o baremetal baremetal.o
# Run: ./baremetal build | init | clean | help

.section .data

# Configuration
content_dir:    .asciz "content"
output_dir:     .asciz "_site"
site_title:     .asciz "Baremetal Site"

# Messages
msg_building:   .asciz "baremetal-ssg: Building site...\n"
msg_building_len = . - msg_building

msg_init:       .asciz "baremetal-ssg: Initializing new site...\n"
msg_init_len = . - msg_init

msg_clean:      .asciz "baremetal-ssg: Cleaning _site/...\n"
msg_clean_len = . - msg_clean

msg_done:       .asciz "baremetal-ssg: Done.\n"
msg_done_len = . - msg_done

msg_proc:       .asciz "  Processing: content/index.md\n"
msg_proc_len = . - msg_proc

msg_written:    .asciz "  Written: _site/index.html\n"
msg_written_len = . - msg_written

msg_help:       .asciz "baremetal-ssg - x86-64 Assembly Static Site Generator\n\nUSAGE:\n  baremetal <command>\n\nCOMMANDS:\n  build    Build the site\n  init     Initialize a new site\n  clean    Remove generated files\n  help     Show this help\n\nFEATURES:\n  - Pure x86-64 assembly\n  - Direct Linux syscalls\n  - Zero runtime dependencies\n  - Minimal binary size\n"
msg_help_len = . - msg_help

# Command strings for comparison
cmd_build:      .asciz "build"
cmd_init:       .asciz "init"
cmd_clean:      .asciz "clean"
cmd_help:       .asciz "help"

# File paths
src_file:       .asciz "content/index.md"
dst_file:       .asciz "_site/index.html"
mkdir_site:     .asciz "_site"
mkdir_content:  .asciz "content"

# Sample content for init
sample_content: .ascii "---\n"
                .ascii "title: Welcome to Baremetal\n"
                .ascii "date: 2025-01-18\n"
                .ascii "---\n\n"
                .ascii "# Welcome\n\n"
                .ascii "This site was built with **baremetal-ssg**, a pure x86-64 assembly SSG.\n\n"
                .ascii "## Assembly Features\n\n"
                .ascii "- Direct syscalls\n"
                .ascii "- Zero dependencies\n"
                .ascii "- Minimal footprint\n"
                .ascii "- Maximum control\n\n"
                .ascii "## Code\n\n"
                .ascii "```asm\n"
                .ascii "mov rax, 1      ; write syscall\n"
                .ascii "mov rdi, 1      ; stdout\n"
                .ascii "syscall\n"
                .ascii "```\n"
sample_content_len = . - sample_content

# HTML template parts
html_doctype:   .ascii "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<title>"
html_doctype_len = . - html_doctype

html_title_end: .ascii "</title>\n<style>\nbody{font-family:monospace;max-width:70ch;margin:0 auto;padding:2rem;}\npre{background:#f5f5f5;padding:1rem;}\n</style>\n</head>\n<body>\n<article>\n"
html_title_end_len = . - html_title_end

html_footer:    .ascii "</article>\n<footer><p>Generated by baremetal-ssg (x86-64 Assembly)</p></footer>\n</body>\n</html>\n"
html_footer_len = . - html_footer

# Markdown tag starts
h1_open:        .asciz "<h1>"
h1_close:       .asciz "</h1>\n"
h2_open:        .asciz "<h2>"
h2_close:       .asciz "</h2>\n"
h3_open:        .asciz "<h3>"
h3_close:       .asciz "</h3>\n"
p_open:         .asciz "<p>"
p_close:        .asciz "</p>\n"
li_open:        .asciz "<li>"
li_close:       .asciz "</li>\n"
pre_open:       .asciz "<pre><code>"
pre_close:      .asciz "</code></pre>\n"

.section .bss
    .lcomm input_buf, 8192      # Input buffer for markdown
    .lcomm output_buf, 16384    # Output buffer for HTML
    .lcomm title_buf, 256       # Title from frontmatter
    .lcomm line_buf, 1024       # Single line buffer
    .lcomm input_len, 8         # Length of input
    .lcomm output_ptr, 8        # Current position in output
    .lcomm in_code, 1           # In code block flag
    .lcomm in_frontmatter, 1    # In frontmatter flag
    .lcomm fm_ended, 1          # Frontmatter ended flag

.section .text
.globl _start

# ============================================================================
# Entry Point
# ============================================================================
_start:
    # Get argc and argv
    mov (%rsp), %rdi            # argc
    lea 8(%rsp), %rsi           # argv

    cmp $2, %rdi                # Need at least 2 args (program + command)
    jl show_help

    # Get command argument (argv[1])
    mov 8(%rsi), %rdi           # argv[1]

    # Check commands
    lea cmd_build(%rip), %rsi
    call str_equal
    test %rax, %rax
    jnz do_build

    lea cmd_init(%rip), %rsi
    call str_equal
    test %rax, %rax
    jnz do_init

    lea cmd_clean(%rip), %rsi
    call str_equal
    test %rax, %rax
    jnz do_clean

    jmp show_help

# ============================================================================
# Build Command
# ============================================================================
do_build:
    # Print building message
    lea msg_building(%rip), %rsi
    mov $msg_building_len, %rdx
    call print_msg

    # Create output directory
    lea mkdir_site(%rip), %rdi
    mov $0755, %rsi
    mov $83, %rax               # mkdir syscall
    syscall

    # Print processing message
    lea msg_proc(%rip), %rsi
    mov $msg_proc_len, %rdx
    call print_msg

    # Read source file
    lea src_file(%rip), %rdi
    call read_file
    test %rax, %rax
    js exit_error

    # Initialize output buffer
    lea output_buf(%rip), %rdi
    mov %rdi, output_ptr(%rip)

    # Parse and convert
    call parse_markdown

    # Write output file
    lea dst_file(%rip), %rdi
    call write_output

    # Print written message
    lea msg_written(%rip), %rsi
    mov $msg_written_len, %rdx
    call print_msg

    # Print done
    lea msg_done(%rip), %rsi
    mov $msg_done_len, %rdx
    call print_msg

    jmp exit_success

# ============================================================================
# Init Command
# ============================================================================
do_init:
    # Print init message
    lea msg_init(%rip), %rsi
    mov $msg_init_len, %rdx
    call print_msg

    # Create content directory
    lea mkdir_content(%rip), %rdi
    mov $0755, %rsi
    mov $83, %rax               # mkdir
    syscall

    # Create _site directory
    lea mkdir_site(%rip), %rdi
    mov $0755, %rsi
    mov $83, %rax
    syscall

    # Write sample content
    lea src_file(%rip), %rdi
    mov $0x242, %rsi            # O_CREAT | O_WRONLY | O_TRUNC
    mov $0644, %rdx
    mov $2, %rax                # open
    syscall

    test %rax, %rax
    js exit_error

    mov %rax, %rdi              # fd
    lea sample_content(%rip), %rsi
    mov $sample_content_len, %rdx
    mov $1, %rax                # write
    syscall

    mov $3, %rax                # close
    syscall

    # Print done
    lea msg_done(%rip), %rsi
    mov $msg_done_len, %rdx
    call print_msg

    jmp exit_success

# ============================================================================
# Clean Command
# ============================================================================
do_clean:
    # Print clean message
    lea msg_clean(%rip), %rsi
    mov $msg_clean_len, %rdx
    call print_msg

    # Remove _site/index.html
    lea dst_file(%rip), %rdi
    mov $87, %rax               # unlink
    syscall

    # Remove _site directory
    lea mkdir_site(%rip), %rdi
    mov $84, %rax               # rmdir
    syscall

    # Print done
    lea msg_done(%rip), %rsi
    mov $msg_done_len, %rdx
    call print_msg

    jmp exit_success

# ============================================================================
# Help Command
# ============================================================================
show_help:
    lea msg_help(%rip), %rsi
    mov $msg_help_len, %rdx
    call print_msg
    jmp exit_success

# ============================================================================
# String Comparison: rdi = str1, rsi = str2
# Returns: rax = 1 if equal, 0 if not
# ============================================================================
str_equal:
    push %rbx
.str_loop:
    movzbl (%rdi), %eax
    movzbl (%rsi), %ebx
    cmp %eax, %ebx
    jne .str_not_equal
    test %eax, %eax
    jz .str_is_equal
    inc %rdi
    inc %rsi
    jmp .str_loop
.str_is_equal:
    mov $1, %rax
    pop %rbx
    ret
.str_not_equal:
    xor %rax, %rax
    pop %rbx
    ret

# ============================================================================
# Print Message: rsi = buffer, rdx = length
# ============================================================================
print_msg:
    mov $1, %rax                # write
    mov $1, %rdi                # stdout
    syscall
    ret

# ============================================================================
# Read File: rdi = filename
# Returns: rax = bytes read (negative on error)
# ============================================================================
read_file:
    push %rbx

    # Open file
    mov $0, %rsi                # O_RDONLY
    mov $2, %rax                # open
    syscall

    test %rax, %rax
    js .read_error

    mov %rax, %rbx              # Save fd

    # Read content
    mov %rbx, %rdi              # fd
    lea input_buf(%rip), %rsi
    mov $8192, %rdx
    xor %rax, %rax              # read
    syscall

    mov %rax, input_len(%rip)   # Save length

    # Close file
    push %rax
    mov %rbx, %rdi
    mov $3, %rax                # close
    syscall
    pop %rax

    pop %rbx
    ret

.read_error:
    pop %rbx
    ret

# ============================================================================
# Parse Markdown
# ============================================================================
parse_markdown:
    push %rbx
    push %r12
    push %r13
    push %r14
    push %r15

    # Initialize state
    movb $0, in_code(%rip)
    movb $0, in_frontmatter(%rip)
    movb $0, fm_ended(%rip)

    # Set default title
    lea title_buf(%rip), %rdi
    movb $'U', (%rdi)
    movb $'n', 1(%rdi)
    movb $'t', 2(%rdi)
    movb $'i', 3(%rdi)
    movb $'t', 4(%rdi)
    movb $'l', 5(%rdi)
    movb $'e', 6(%rdi)
    movb $'d', 7(%rdi)
    movb $0, 8(%rdi)

    lea input_buf(%rip), %r12    # Input pointer
    mov input_len(%rip), %r13    # Input length
    add %r12, %r13               # Input end

    # First pass: find frontmatter
    call parse_frontmatter

    # Write HTML header
    lea html_doctype(%rip), %rsi
    mov $html_doctype_len, %rcx
    call emit_bytes

    # Write title
    lea title_buf(%rip), %rsi
    call emit_string

    # Write title end and style
    lea html_title_end(%rip), %rsi
    mov $html_title_end_len, %rcx
    call emit_bytes

    # Write title as H1
    lea h1_open(%rip), %rsi
    call emit_string
    lea title_buf(%rip), %rsi
    call emit_string
    lea h1_close(%rip), %rsi
    call emit_string

    # Reset input pointer to body start
    lea input_buf(%rip), %r12
    cmpb $0, fm_ended(%rip)
    jz .parse_body

    # Skip frontmatter
.skip_fm_loop:
    cmp %r13, %r12
    jge .parse_done
    movzbl (%r12), %eax
    inc %r12
    cmp $10, %al                # newline
    jne .skip_fm_loop

    # Check for ---
    cmpb $'-', (%r12)
    jne .skip_fm_loop
    cmpb $'-', 1(%r12)
    jne .skip_fm_loop
    cmpb $'-', 2(%r12)
    jne .skip_fm_loop
    add $4, %r12                # Skip past --- and newline

.parse_body:
    # Parse each line
.parse_line_loop:
    cmp %r13, %r12
    jge .parse_done

    # Read line into line_buf
    lea line_buf(%rip), %rdi
    xor %r14, %r14              # Line length

.read_line:
    cmp %r13, %r12
    jge .line_done
    movzbl (%r12), %eax
    inc %r12
    cmp $10, %al                # newline
    je .line_done
    mov %al, (%rdi, %r14)
    inc %r14
    cmp $1023, %r14
    jl .read_line

.line_done:
    movb $0, (%rdi, %r14)       # Null terminate

    # Process line
    call process_line

    jmp .parse_line_loop

.parse_done:
    # Write footer
    lea html_footer(%rip), %rsi
    mov $html_footer_len, %rcx
    call emit_bytes

    pop %r15
    pop %r14
    pop %r13
    pop %r12
    pop %rbx
    ret

# ============================================================================
# Parse Frontmatter
# ============================================================================
parse_frontmatter:
    push %r12
    push %r13

    lea input_buf(%rip), %r12
    mov input_len(%rip), %r13
    add %r12, %r13

    # Check for ---
    cmpb $'-', (%r12)
    jne .no_fm
    cmpb $'-', 1(%r12)
    jne .no_fm
    cmpb $'-', 2(%r12)
    jne .no_fm

    movb $1, in_frontmatter(%rip)
    add $4, %r12                # Skip --- and newline

.fm_loop:
    cmp %r13, %r12
    jge .fm_done

    # Check for closing ---
    cmpb $'-', (%r12)
    jne .fm_parse_line
    cmpb $'-', 1(%r12)
    jne .fm_parse_line
    cmpb $'-', 2(%r12)
    jne .fm_parse_line

    movb $1, fm_ended(%rip)
    jmp .fm_done

.fm_parse_line:
    # Check for title:
    cmpb $'t', (%r12)
    jne .fm_skip_line
    cmpb $'i', 1(%r12)
    jne .fm_skip_line
    cmpb $'t', 2(%r12)
    jne .fm_skip_line
    cmpb $'l', 3(%r12)
    jne .fm_skip_line
    cmpb $'e', 4(%r12)
    jne .fm_skip_line
    cmpb $':', 5(%r12)
    jne .fm_skip_line

    # Copy title value
    add $6, %r12                # Skip "title:"

    # Skip whitespace
.skip_ws:
    cmpb $' ', (%r12)
    jne .copy_title
    inc %r12
    jmp .skip_ws

.copy_title:
    lea title_buf(%rip), %rdi
    xor %rax, %rax
.copy_title_loop:
    cmp %r13, %r12
    jge .copy_title_done
    movzbl (%r12), %ecx
    cmp $10, %cl                # newline
    je .copy_title_done
    mov %cl, (%rdi, %rax)
    inc %rax
    inc %r12
    cmp $255, %rax
    jl .copy_title_loop

.copy_title_done:
    movb $0, (%rdi, %rax)       # Null terminate
    jmp .fm_loop

.fm_skip_line:
    # Skip to next line
    cmp %r13, %r12
    jge .fm_done
    movzbl (%r12), %eax
    inc %r12
    cmp $10, %al
    jne .fm_skip_line
    jmp .fm_loop

.no_fm:
.fm_done:
    pop %r13
    pop %r12
    ret

# ============================================================================
# Process Line: line_buf contains the line
# ============================================================================
process_line:
    push %rbx

    lea line_buf(%rip), %rbx

    # Skip leading whitespace for comparison
    mov %rbx, %rdi
.skip_leading:
    cmpb $' ', (%rdi)
    jne .check_line
    inc %rdi
    jmp .skip_leading

.check_line:
    # Check for code fence ```
    cmpb $'`', (%rdi)
    jne .check_header
    cmpb $'`', 1(%rdi)
    jne .check_header
    cmpb $'`', 2(%rdi)
    jne .check_header

    # Toggle code block
    cmpb $0, in_code(%rip)
    jnz .close_code

    # Open code block
    movb $1, in_code(%rip)
    lea pre_open(%rip), %rsi
    call emit_string
    jmp .line_done

.close_code:
    movb $0, in_code(%rip)
    lea pre_close(%rip), %rsi
    call emit_string
    jmp .line_done

.check_header:
    # In code block, emit as-is
    cmpb $0, in_code(%rip)
    jz .not_in_code

    lea line_buf(%rip), %rsi
    call emit_string
    movb $10, %al               # newline
    call emit_char
    jmp .line_done

.not_in_code:
    # Check for ### header
    cmpb $'#', (%rdi)
    jne .check_list
    cmpb $'#', 1(%rdi)
    jne .h1_check
    cmpb $'#', 2(%rdi)
    jne .h2_check
    cmpb $' ', 3(%rdi)
    jne .check_list

    # H3
    lea h3_open(%rip), %rsi
    call emit_string
    lea 4(%rdi), %rsi           # Skip "### "
    call emit_string
    lea h3_close(%rip), %rsi
    call emit_string
    jmp .line_done

.h2_check:
    cmpb $' ', 2(%rdi)
    jne .check_list

    # H2
    lea h2_open(%rip), %rsi
    call emit_string
    lea 3(%rdi), %rsi           # Skip "## "
    call emit_string
    lea h2_close(%rip), %rsi
    call emit_string
    jmp .line_done

.h1_check:
    cmpb $' ', 1(%rdi)
    jne .check_list

    # H1
    lea h1_open(%rip), %rsi
    call emit_string
    lea 2(%rdi), %rsi           # Skip "# "
    call emit_string
    lea h1_close(%rip), %rsi
    call emit_string
    jmp .line_done

.check_list:
    # Check for - or * list item
    cmpb $'-', (%rdi)
    je .is_list
    cmpb $'*', (%rdi)
    jne .check_paragraph

.is_list:
    cmpb $' ', 1(%rdi)
    jne .check_paragraph

    lea li_open(%rip), %rsi
    call emit_string
    lea 2(%rdi), %rsi           # Skip "- " or "* "
    call emit_string
    lea li_close(%rip), %rsi
    call emit_string
    jmp .line_done

.check_paragraph:
    # Empty line
    cmpb $0, (%rdi)
    je .line_done

    # Regular paragraph
    lea p_open(%rip), %rsi
    call emit_string
    mov %rdi, %rsi
    call emit_string
    lea p_close(%rip), %rsi
    call emit_string

.line_done:
    pop %rbx
    ret

# ============================================================================
# Emit Bytes: rsi = source, rcx = count
# ============================================================================
emit_bytes:
    push %rdi
    mov output_ptr(%rip), %rdi
    rep movsb
    mov %rdi, output_ptr(%rip)
    pop %rdi
    ret

# ============================================================================
# Emit String: rsi = null-terminated string
# ============================================================================
emit_string:
    push %rdi
    push %rax
    mov output_ptr(%rip), %rdi
.emit_str_loop:
    lodsb
    test %al, %al
    jz .emit_str_done
    stosb
    jmp .emit_str_loop
.emit_str_done:
    mov %rdi, output_ptr(%rip)
    pop %rax
    pop %rdi
    ret

# ============================================================================
# Emit Char: al = character
# ============================================================================
emit_char:
    push %rdi
    mov output_ptr(%rip), %rdi
    stosb
    mov %rdi, output_ptr(%rip)
    pop %rdi
    ret

# ============================================================================
# Write Output: rdi = filename
# ============================================================================
write_output:
    push %rbx

    # Open file for writing
    mov $0x242, %rsi            # O_CREAT | O_WRONLY | O_TRUNC
    mov $0644, %rdx
    mov $2, %rax                # open
    syscall

    test %rax, %rax
    js .write_error

    mov %rax, %rbx              # Save fd

    # Calculate length
    mov output_ptr(%rip), %rdx
    lea output_buf(%rip), %rsi
    sub %rsi, %rdx              # Length = ptr - buf

    # Write content
    mov %rbx, %rdi              # fd
    mov $1, %rax                # write
    syscall

    # Close file
    mov %rbx, %rdi
    mov $3, %rax                # close
    syscall

    pop %rbx
    ret

.write_error:
    pop %rbx
    ret

# ============================================================================
# Exit
# ============================================================================
exit_success:
    xor %rdi, %rdi              # Exit code 0
    mov $60, %rax               # exit
    syscall

exit_error:
    mov $1, %rdi                # Exit code 1
    mov $60, %rax               # exit
    syscall
